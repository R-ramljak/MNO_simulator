---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r}
library(data.table) 
library(tidyverse)
library(lubridate)
library(sf)
library(raster)
library(furrr)
library(stars)
library(knitr)
library(DT)
library(Matrix)
library(ggthemes)
library(ggsn)
library(grid)
library(gridExtra)
library(mobloc)
library(mobvis)
library(SpatialKWD)
set.seed(761)

source("pipeline functions.R")

```

## Create population

```{r}
# tile.num <- 100 # number of tiles
# base.tile.size <- 100 # size of a single tile
# city.num <- 1 # number of single cities
# city.size <- 10 # size of a single city polygon
# hole.num <- 1 # number of single holes
# hole.size <- 1 # size of a single hole polygon
# pop.dist.df <- tibble(type = c("Urban", "Hole", "Rural"),
#                       exprssion = c("ReIns::rtpareto(shape = 0.05, scale = 10, endpoint = 200",
#                                     "ReIns::rtpareto(shape = 0.7, scale = 0.1, endpoint = 20",
#                                     "ReIns::rtpareto(shape = 0.5, scale = 0.1, endpoint = 100"))
# 
# 
# tm.pop_gen <- system.time(
#   {
#       area <- pop_gen(tile.num, base.tile.size,
#                           city.num, city.size, city.shape = "SQUARE",
#                           hole.num, hole.size, hole.shape = "SQUARE",
#                           pop.dist.ls)
#   })
# 
# 
# # e <- st_sample(area$area.union, 10) %>% 
# #   st_jitter(30) %>% 
# #   st_sf() %>% 
# #   mutate(id = sample(1:10, 10, replace = F)) %>% 
# #   mutate(Kind = case_when(id <= 7 ~ "Meso",
# #                           TRUE ~ "Macro"))
# # 
# # vor <- e %>% 
# #   st_geometry() %>% 
# #   st_union() %>% 
# #   st_voronoi() %>% 
# #   st_collection_extract(type = "POLYGON") %>% 
# #   st_sf() %>% # check if crs is listed
# #   st_join(e) %>%  # rejoin with seed object to retain seed id
# #   st_intersection(area$area.union)
# # 
# # q <- vor %>% 
# #   ggplot() +
# #   geom_sf(fill = "transparent") +
# #   geom_sf(data = e, size = 1) +
# #   theme_void() +
# #   theme(legend.position = "none")
# # 
# # ggsave("example1.png", q)
# # 
# # a <- area$area.union %>% 
# #   ggplot() +
# #   geom_sf(fill = "transparent") +
# #   geom_sf(data = e, size = 1) +
# #   theme_void() +
# #   theme(legend.position = "none")
# # 
# # ggsave("example2.png", a)
# # 
# # area$area.sf %>% 
# #   ggplot() +
# #   geom_sf() +
# #   geom_sf(data = e)
# 
# 
# 
# 
# 
# 
# 
# # check result
# (type.plot <- type_plot(area$area.sf))
# 
# (pop.plot <- pop_plot(area$area.sf))
# 
# (summary.results <- pop_summary_results(area$area.sf))
# 
# time.results <- tibble(output = c("Population Generation"),
#                        "function" = c("pop_gen()"),
#                        time = c(round(seconds_to_period(tm.pop_gen[1]), 2)),
#                        n.tile = c(length(area$area.sf$tile.id)),
#                        tile.site = paste(base.tile.size, "x", base.tile.size),
#                        pop.total = c(sum(area$area.sf$pop)))
# 
# (density.plots <- density_plots(area$area.df))


```


```{r}
# munich
munich.raw <- readRDS("C:/Users/Marco/Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/working objects/munich.rds")

munich.raster <- rasterFromXYZ(munich.raw, crs = st_crs(3035)$proj4string)
munich <- NULL

munich$area.sf <- munich.raster %>%
  st_as_stars() %>%
  st_as_sf() %>%
  dplyr::select(tile.id, pop, elevation) %>%
  mutate(type = "NA")

munich$area.df <- munich$area.sf %>%
  st_drop_geometry()

munich$area.union <- munich$area.sf %>%
  st_union()

munich$area.bbox <- munich$area.union %>%
  st_bbox(crs = sf::st_crs(3035))

munich$area.raster <- munich.raster %>%
  raster(., layer = "tile.id")

munich$area.elevation <- munich.raster %>%
  raster(., layer = "elevation")

munich$area.params[["tile.num"]] <- length(munich$area.df$tile.id)
munich$area.params[["base.tile.size"]] <- as.numeric(sqrt(st_area(munich$area.sf[1,])))


# check results
(pop.plot <- pop_plot(munich$area.sf))

(summary.results <- pop_summary_results(munich$area.sf))

(density.plots <- density_plots(munich$area.df))

## renaming
area <- munich
```



## Create radio network

```{r, fig.height=8, fig.width=10}
# specify parameters of each cell
MA.cell.param.mobloc <- mobloc_param(W = 5, range = 10000, ple = 3.4, height = 10,
                                     midpoint = -85, steepness = 0.15, sig_d_th = 0.05)

ME.cell.param.mobloc <- mobloc_param(W = 50, range = 3500, ple = 3.8, height = 10,
                                     midpoint = -85, steepness = 0.3, sig_d_th = 0.05)

# create dataframe for theoretical signal strength distribution
param.df <- tibble(cell.kind = c("MA", "ME"),
                   label = c("Macro", "Meso"),
                   W = c(MA.cell.param.mobloc$W, ME.cell.param.mobloc$W),
                   ple = c(MA.cell.param.mobloc$ple, ME.cell.param.mobloc$ple),
                   range = c(MA.cell.param.mobloc$range, ME.cell.param.mobloc$range),
                   midpoint = c(MA.cell.param.mobloc$midpoint, ME.cell.param.mobloc$midpoint),
                   steepness = c(MA.cell.param.mobloc$steepness, ME.cell.param.mobloc$steepness),
                   dominance.th = c(MA.cell.param.mobloc$sig_d_th,
                                    ME.cell.param.mobloc$sig_d_th))

param.df.reduced <- param.df %>% 
  dplyr::select(cell.kind, dominance.th)

# visualize theoretical signal parameter plots
sig.pram.plots <- sig_param_plots(param.df = param.df, range.max = 20000, base_size = 11)
a <- ggpubr::as_ggplot(sig.pram.plots$final)
ggsave("coverage_contur/coverage.diag.png", a, device = "png", width = 10)
```

```{r}
set.seed(100)

# create tower positions with attached cells
MA.cells.unparam <- create_cells(area.sf = area$area.sf, 
                                 tower.dist = 8500, rotation.deg = 0, 
                                 jitter = 1000, small = FALSE, 
                                 subscript = "MA", seed = 3)

ME.cells.unparam <- create_cells(area.sf = area$area.sf,
                                 tower.dist = 4200, rotation.deg = 35,
                                 jitter = 700, small = FALSE,
                                 subscript = "ME", seed = 7)


# create the cellplan and validate it with the specified parameters
MA.cellplan.val <- create_cellplan(area.sf = area$area.sf,  
                                   area.bbox = area$area.bbox, 
                                   area.elevation = area$area.elevation,
                                   cells.unparam = MA.cells.unparam,
                                   cell.param.mobloc = MA.cell.param.mobloc)

ME.cellplan.val <- create_cellplan(area.sf = area$area.sf,
                                   area.bbox = area$area.bbox,
                                   area.elevation = area$area.elevation,
                                   cells.unparam = ME.cells.unparam,
                                   cell.param.mobloc = ME.cell.param.mobloc)

cellplan.combined <- bind_rows(as_tibble(MA.cellplan.val$cellplan.val),
                               as_tibble(ME.cellplan.val$cellplan.val)) %>% 
  mutate(cell.kind = substr(cell, 1, 2)) %>% 
  left_join(param.df.reduced, by = "cell.kind") # join dominance threshold to use later in create_strength_llh()

# to join variable dominance.th later on
cellplan.combined.reduced <- cellplan.combined %>% 
  dplyr::select(cell, dominance.th)


# compute signal strength and device to cell association
MA.signal.strength <- compute_sig_strength(cp = MA.cellplan.val$cellplan.val, 
                                           raster = area$area.raster, 
                                           param = MA.cellplan.val$cell.param.mobloc, 
                                           elevation = area$area.elevation)

ME.signal.strength <- compute_sig_strength(cp = ME.cellplan.val$cellplan.val,
                                           raster = area$area.raster,
                                           param = ME.cellplan.val$cell.param.mobloc,
                                           elevation = area$area.elevation)

# create signal strength object of all cells
signal.strength.comb.dt <- rbindlist(list(MA.signal.strength,
                                          ME.signal.strength))

  


signal.strength.summary.helper <- signal.strength.comb.dt %>%
  as_tibble() %>%
  mutate(tile.id = as.character(rid)) %>%
  mutate(cell.kind = substr(cell, 1, 2)) %>%
  mutate(cell.chr = as.character(cell)) %>%
  left_join(cellplan.combined.reduced, by = c("cell.chr" = "cell")) %>% 
  filter(!s < dominance.th) # filter rows out that are below the set dominance threshold

signal.strength.summary <- signal.strength.summary.helper %>% 
  group_by(tile.id) %>%
  mutate(max.dBm = max(dBm),
         max.s = max(s),
         min.dist = min(dist)) %>%
  ungroup()


# identify the cell-tile relations with maximum signal dominance and identify tiles that are not covered sufficiently
signal.dom <- signal.strength.summary %>% 
  distinct(tile.id, max.s) %>%
  left_join(signal.strength.summary, by = c("tile.id", "max.s" = "s")) %>% 
  dplyr::select(tile.id, max.s, cell, cell.kind) %>% 
  mutate(tile.id = as.integer(tile.id)) %>% 
  full_join(area$area.sf, by = "tile.id") %>% 
  mutate(missing = case_when(is.na(max.s) ~ 1,
                             TRUE ~ 0))

# how many tiles are not sufficiently covered
paste0("Number of tiles which do not reach the signal dominance threshold of: " , sum(signal.dom$missing))
# paste0("Number of tiles which do not reach the signal dominance threshold of ", sig_d_th, ": " , sum(signal.dom$missing))
  
```


# develop finder grid for contour plots
```{r}
finer.grid.factor <- 2
finer.grid.tile.id <- c(1:640000) # adjust to grid factor

area$area.raster.finer <- disaggregate(area$area.raster, finer.grid.factor) %>% 
  setValues(., finer.grid.tile.id)

area$area.elevation.finer <- disaggregate(area$area.elevation, finer.grid.factor)

area$area.finer.grid.sf <- st_as_sf(st_as_stars(area$area.raster.finer))

# compute signal strength and device to cell association
MA.signal.strength.finer <- compute_sig_strength(cp = MA.cellplan.val$cellplan.val, 
                                                 raster = area$area.raster.finer, 
                                                 param = MA.cellplan.val$cell.param.mobloc, 
                                                 elevation = area$area.elevation.finer)

ME.signal.strength.finer <- compute_sig_strength(cp = ME.cellplan.val$cellplan.val,
                                                 raster = area$area.raster.finer,
                                                 param = ME.cellplan.val$cell.param.mobloc,
                                                 elevation = area$area.elevation.finer)

signal.strength.comb.dt.finer.grid <- rbindlist(list(MA.signal.strength.finer,
                                                     ME.signal.strength.finer))

tictoc::tic()
area.reduced.contour <- area$area.finer.grid.sf %>% 
  dplyr::select(tile.id.num = tile.id) %>% 
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]]))
tictoc::toc()

crs.set <- st_crs(area.reduced.contour)

contour.data.raw <- signal.strength.comb.dt.finer.grid %>%
  as_tibble() %>%
  mutate(tile.id.num = as.numeric(rid)) %>%
  mutate(cell.chr = as.character(cell)) %>%
  left_join(cellplan.combined, by = c("cell.chr" = "cell")) %>% 
  filter(!s < dominance.th) %>% 
  mutate(s.discrete = case_when(s <= 0.5 ~ 1,
                                s > 0.5 ~ 2)) %>% 
  dplyr::select(cell, cell.kind, x.tow = x, y.tow = y, direction, tile.id.num, s, s.discrete) %>% 
  left_join(area.reduced.contour, by = c("tile.id.num")) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = crs.set) 

contour.data.raw.MA <- contour.data.raw %>% 
  st_drop_geometry() %>% 
  filter(cell.kind == "MA") %>% 
  distinct(cell, x.tow, y.tow)

contour.data.raw.ME <- contour.data.raw %>% 
  st_drop_geometry() %>% 
  filter(cell.kind == "ME") %>% 
  distinct(cell, x.tow, y.tow)

contour.data.summary <- contour.data.raw %>% 
  dplyr::select(cell, cell.kind, s.discrete, s) %>% 
  dplyr::group_by(cell, cell.kind, s.discrete) %>%
  dplyr::summarise() %>%
  # st_cast("POLYGON") %>%
  st_convex_hull()

contour.complete.MA <- contour.data.summary %>% 
  filter(cell.kind == "MA" & s.discrete == "1") %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(color = "red", fill = "transparent") +
  geom_point(data = contour.data.raw.MA, aes(x = x.tow, y = y.tow), color = "black", size = 2) +
  theme_minimal() +
  labs(x = "", y = "")
ggsave("coverage_contur/complete.MA.finer.png", contour.complete.MA, device = "png")

contour.complete.ME <- contour.data.summary %>% 
  filter(cell.kind == "ME" & s.discrete == "1") %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(color = "red", fill = "transparent") +
  geom_point(data = contour.data.raw.ME, aes(x = x.tow, y = y.tow), color = "blue", shape = 2) +
  theme_minimal() +
  labs(x = "", y = "")
ggsave("coverage_contur/complete.ME.finer.png", contour.complete.ME, device = "png")


contour.certain <- contour.data.summary %>% 
  filter(str_detect(cell, "MA.12.|ME.100.")) %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(aes(color = factor(s.discrete)), fill = "transparent") +
  geom_point(data = contour.data.raw.MA, aes(x = x.tow, y = y.tow), color = "black", size = 2) +
  geom_point(data = contour.data.raw.ME, aes(x = x.tow, y = y.tow), color = "blue", shape = 2) +
  scale_color_discrete("Signal dom.", breaks = c("1", "2"), labels = c("0.05 <= s < 0.5",
                                                                      "s >= 0.5")) +
  theme_minimal() +
  labs(x = "", y = "")
ggsave("coverage_contur/hull.certain.finer.png", contour.certain, device = "png")
```



```{r}
tictoc::tic()
# maximum of two rows per tile, tiles with only one row, mean they are only covered by one cell.kind
signal.strength.summary.ck <- signal.strength.summary.helper %>% 
  group_by(tile.id, cell.kind) %>%
  summarise(cell.count = n(),
            max.dBm = max(dBm),
            max.s = max(s),
            min.dist = min(dist)) %>% 
  mutate(cell.count.complete = sum(cell.count),
         max.dBm.complete = max(max.dBm),
         max.s.complete = max(max.s), 
         min.dist.complete = max(min.dist)) %>% 
  ungroup() %>% 
  pivot_longer(cols = -c(tile.id, cell.kind),
               names_to = "kind", 
               values_to = "values") # possibly different pivot to get "kind" into multiple variables


# histogram cells
tile.coverage.hist <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "count")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  distinct(tile.id, cat, .keep_all = T) %>% 
  dplyr::select(-cell.kind) %>% 
  ggplot() +
  geom_histogram(aes(values), binwidth = 1) +
  # scale_x_continuous(breaks = seq(0, 12, 1)) + # respecify to be dynamic
  facet_grid(~cat) +
  labs(title = "Number of cells a tile is covered by",
       y = "Tile count",
       x = "Number of cells")


# build graph with rotating triangle
coverage.map.dom.df.MA <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "MA") %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.dom.df.ME <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "ME") %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.dom.df.complete <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "complete") %>% 
  distinct(tile.id, cat, .keep_all = T) %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.MA <- coverage.map.dom.df.MA %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = as_tibble(MA.cellplan.val$cellplan.val), aes(x, y),
             shape = 2, color = "#F8766D") +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = "MA Coverage", 
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")

coverage.map.ME <- coverage.map.dom.df.ME %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = as_tibble(ME.cellplan.val$cellplan.val), aes(x, y),
             shape = 2, color = "#00BFC4") +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = " ME Coverage", 
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

coverage.map.complete <- coverage.map.dom.df.complete %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = cellplan.combined, aes(x, y, color = cell.kind),
             shape = 2) +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = "Complete coverage", 
       color = "Tower kind",
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

# coverage.map.dom.df.binary <- signal.strength.summary.ck %>%
#   filter(str_detect(kind, pattern = "max.s"),
#          !str_detect(kind, pattern = "complete")) %>%
#   group_by(tile.id) %>%
#   # mutate(values = round(values, 2)) %>% 
#   filter(values == max(values)) %>%
#   ungroup() %>%
#   mutate(tile.id.num = as.numeric(tile.id)) %>%
#   full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
#   mutate(missing = case_when(is.na(values) ~ 1,
#                              TRUE ~ 0)) %>%
#   st_as_sf()
# 
# 
# coverage.map.binary <- coverage.map.dom.df.binary %>%
#   sample_n(2000) %>% 
#   ggplot() +
#   geom_sf(aes(fill = cell.kind), color = "transparent", alpha = 0.3, show = FALSE) +
#   geom_point(data = cellplan.combined, aes(x, y, color = cell.kind),
#              shape = 2) +
#   labs(title = "Binary coverage",
#        color = "Tower kind",
#        x = "",
#        y = "") +
#   theme(axis.title.x = element_blank(),
#         axis.text.x = element_blank(),
#         axis.ticks.x = element_blank(),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())

coverage.diag <- arrangeGrob(coverage.map.MA, coverage.map.ME, 
                             coverage.map.complete, tile.coverage.hist, 
                             layout_matrix = rbind(c(1, 2),
                                                   c(3, 4)))
# coverage.map.MA
# coverage.map.ME
# coverage.map.complete
# tile.coverage.hist



```


## Device to cell association

```{r}
# specify the option of differing parameters for sig_d_th and max_overlapping_cells depending on the cell type in custom create_strength_llh function

# Workaround: securing that sig_d_th and max_overlapping_cells are the same
signal.strength.llh.param <- list(sig_d_th = max(cellplan.combined.reduced$dominance.th),
                                  max_overlapping_cells = 100)


# creating the long format of the P matrix
# MA.signal.strength.llh <- create_strength_llh(strength = MA.signal.strength, 
#                                               param = signal.strength.llh.param)
# 
# ME.signal.strength.llh <- create_strength_llh(strength = ME.signal.strength, 
#                                               param = signal.strength.llh.param)

signal.strength.llh.combined <- create_strength_llh(strength = signal.strength.comb.dt, 
                                                    param = signal.strength.llh.param) %>% 
  as_tibble() %>% 
  mutate(tile.id = rid) %>% 
  group_by(tile.id) %>%
  mutate(pij = smart.round(pag, 3)) %>%
  ungroup() %>%
  left_join(area$area.df, by = "tile.id") %>% 
  mutate(coverage.kind = case_when(pop == 0 ~ "0 population",
                                   pij == 1 ~ "covered completely by one antenna",
                                   pij > 0 & pij < 1 ~ "covered by multiple antennas",
                                   pij == 0 ~ "tile covered unsufficiently")) %>% 
  dplyr::select(-pag)

# aggregating and specifing the tiles that are uncovered 
tiles.cat <- signal.strength.llh.combined %>% 
  filter(!pij == 0) %>% 
  dplyr::select(tile.id, coverage.kind) %>% 
  group_by(tile.id) %>% 
  summarise(count = n())

# how many tiles are not sufficiently covered
missings <- anti_join(area$area.df, tiles.cat, by = "tile.id") # implement non zero pop
paste("Number of tiles which are unsufficiently covered:", length(missings$tile.id))

# covered only by one tile
C.vec.fixed.helper <- signal.strength.llh.combined %>% 
  filter(coverage.kind == "covered completely by one antenna") %>%
  dplyr::select(tile.id, cell, pop)

# One object where tiles are covered by multiple cells
C.vec.multiple.helper <- signal.strength.llh.combined %>% 
  filter(coverage.kind == "covered by multiple antennas") %>% 
  group_split(tile.id) 

tictoc::tic()
# Calculate the number of cores
no_cores <- availableCores() - 1
plan(multisession, workers = no_cores)

C.vec.multiple <- C.vec.multiple.helper %>% 
  future_map(~sample(x = .$cell, mean(.$pop),
                     replace = T, prob = .$pij), 
             .options = furrr_options(seed = T), .progress = T) %>% 
  future_map(as_tibble, .id = "tile.id", .progress = T) %>% 
  future_map(~group_by(., value), .progress = T) %>% 
  future_map(~summarise(., pop.count.rand = n(), .groups = "drop"), 
             .progress = T)
tictoc::toc()

C.vec.df <- C.vec.multiple %>% 
  bind_rows() %>% 
  dplyr::select(cell = value, pop = pop.count.rand) %>% 
  bind_rows(C.vec.fixed.helper) %>% 
  group_by(cell) %>% 
  summarise(phones.sum = sum(pop))

(c.vec.hist <- C.vec.df %>% 
  ggplot() +
  geom_histogram(aes(phones.sum)) +
  labs(title = "Number of phones a cell has registered",
       y = "Cell count",
       x = "Number of phones"))
```

```{r}
P.long.complete.df <- full_join(signal.strength.llh.combined, C.vec.df, by = "cell") %>% 
  # dplyr::select(tile.id, pop, elevation, cell, type, dist, pij, phones.sum) %>% 
  dplyr::select(tile.id, pop, cell, type, dist, pij, phones.sum) %>% 
  mutate(tile.id.chr = tile.id) %>% 
  mutate(tile.id = factor(tile.id)) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  mutate(cell.num = as.numeric(cell)) %>% 
  mutate(cell.chr = as.character(cell))

P.long.df <- P.long.complete.df %>% 
  dplyr::select(tile.id, tile.id.num, tile.id.chr, cell, cell.num, cell.chr, pij) %>% 
  distinct()


P.mat <- sparseMatrix(i = P.long.df$cell.num, 
                      j = P.long.df$tile.id.num, 
                      x = P.long.df$pij)


#### P star oracle
# P.star.oracle.dt <- data.table(i = P.long.df$cell.num,
#                                j = P.long.df$tile.id.num,
#                                pij = P.long.df$pij)

P.star.oracle.dt.d <- P.long.df %>% 
  dplyr::select(i = cell.num, j = tile.id.num, pij) %>% 
  as.data.table()

#### P star equal
P.star.equal.dt <- P_equalizer(P.long.df, signal.strength.comb.dt) %>% 
  dplyr::select(i = cell.num, j = tile.id.num, pij = pij.equal) %>% 
  as.data.table()


# P.new <- P.long.df %>% 
#   mutate(pij.new = 1) %>% # same prob for all non-zero relationships
#   group_by(tile.id.num) %>% 
#   mutate(pij.new = pij.new / sum(pij.new)) %>%
#   ungroup() %>% 
#   as.data.table()
# 
# d <- P.new %>% 
#   filter(str_detect(cell, "MA.12.")) %>% 
#   left_join(area$area.sf, by = c("tile.id.chr")) %>% 
#   mutate(tile.id.chr = as.character(tile.id.chr)) %>% 
#   left_join(signal.strength.summary.helper, by = c("cell", "tile.id.chr" = "tile.id")) %>% 
#   st_sf()
# 
# s.plot <- d %>% 
#   # group_by(tile.id.chr) %>% 
#   # mutate(f = max())  %>% 
#   ggplot() +
#   geom_sf(aes(fill = s), color = "transparent") +
#   facet_wrap(vars(cell)) +
#   labs(title = "signal dominance") +
#   theme(axis.text = element_text(size = 4))
# 
# oracle.plot <- d %>% 
#   ggplot() +
#   geom_sf(aes(fill = pij), color = "transparent") +
#   facet_wrap(vars(cell))+
#   labs(title = "oracle") +
#   theme(axis.text = element_text(size = 4))
# 
# 
# equal.plot <- d %>% 
#   ggplot() +
#   geom_sf(aes(fill = pij.new), color = "transparent") +
#   facet_wrap(vars(cell))+
#   labs(title = "equal") +
#   theme(axis.text = element_text(size = 4))
# 
# coverage.example <- arrangeGrob(s.plot, oracle.plot, equal.plot,
#                                 layout_matrix = rbind(c(1),
#                                                       c(2),
#                                                       c(3)))
# 
# ggsave("coverage.example.png", coverage.example, device = "png")
# 


```


## Estimation

```{r}
# Estimation object prep

#### Specify P* with super tiles 
P.star.supertile.helper <- P.long.df %>% 
  dplyr::select(tile.id.chr, cell.chr, pij) %>% 
  filter(!pij == 0) %>%
  group_by(tile.id.chr) %>% 
  arrange(cell.chr) %>% 
  mutate(cell.comp = paste0(cell.chr, collapse = ""),
         pij.comp = paste0(pij, collapse = "")) %>% 
  ungroup() %>% 
  group_by(cell.comp, pij.comp) %>% 
  mutate(supertile.id = cur_group_id()) %>% 
  ungroup() %>% 
  mutate(supertile.id = factor(supertile.id)) %>% 
  mutate(supertile.id.num = as.numeric(supertile.id)) %>% 
  mutate(supertile.id.chr = as.character(supertile.id)) %>% 
  right_join(P.long.df, by = c("tile.id.chr", "cell.chr")) %>% 
  dplyr::select(tile.id, tile.id.num, tile.id.chr, supertile.id, supertile.id.num, supertile.id.chr, cell, cell.num, cell.chr, pij = pij.x) %>% 
  filter(!is.na(pij)) # check this

P.star.supertile.joiner <- P.star.supertile.helper %>%  
  distinct(tile.id, tile.id.num, tile.id.chr, supertile.id, supertile.id.num, supertile.id.chr) %>% 
  arrange(tile.id) 

# append supertile id to sim area base objects
area$area.sf <- area$area.sf %>% 
  left_join(P.star.supertile.joiner, by = c("tile.id" = "tile.id.num"))
area$area.df <- area$area.df %>% 
  left_join(P.star.supertile.joiner, by = c("tile.id" = "tile.id.num"))

  
P.star.supertile.helper %>%  
  distinct(tile.id, tile.id.num, tile.id.chr, supertile.id, supertile.id.num, supertile.id.chr, .keep_all = T) %>% 
  group_by(supertile.id.num) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(n) %>% 
  summarise(count = n()) %>% 
  datatable(caption = "Distribution of supertiles", rownames = F)


P.star.supertile.long.df <- P.star.supertile.helper %>%
  distinct(supertile.id, supertile.id.num, supertile.id.chr, cell, cell.num, cell.chr, pij) %>% 
  arrange(cell.num)

P.star.oracle.supertile.spm <- sparseMatrix(i = P.star.supertile.long.df$cell.num, 
                                            j = P.star.supertile.long.df$supertile.id.num, 
                                            x = P.star.supertile.long.df$pij)

P.star.oracle.supertile.dt <- data.table(i = P.star.supertile.long.df$cell.num,
                                         j = P.star.supertile.long.df$supertile.id.num,
                                         pij = P.star.supertile.long.df$pij)

# P.star.equal.supertile.dt <- P.star.supertile.long.df %>% 
#   mutate(pij = 1) %>% # same prob for all non-zero relationships
#   dplyr::select(i = cell.num, j = supertile.id.num, pij) %>% 
#   group_by(j) %>% 
#   mutate(pij = smart.round(pij / sum(pij), 3)) %>% 
#   ungroup() %>% 
#   as.data.table()


## show histogram of P.star.supertile.summary



### C vector, adding antennas that have 0 phones to complete the vector, arranging it according to the antenna.ID and saving as vector
c.vec <- P.long.complete.df %>% 
  distinct(cell, cell.num, cell.chr, phones.sum) %>% 
  right_join(cellplan.combined, by = "cell") %>% 
  mutate(phones.sum = case_when(is.na(phones.sum) ~ 0,
                                TRUE ~ phones.sum)) %>% 
  arrange(cell.num)

c.vec.dt <- data.table(i = c.vec$cell.num,
                       c = c.vec$phones.sum)


### prior vectors
a.tile.helper <- P.long.complete.df %>% 
  mutate(a = 1) %>% 
  distinct(tile.id.num, a)
a.tile.dt <- data.table(j = a.tile.helper$tile.id.num, u = a.tile.helper$a)

a.supertile.helper <- P.star.supertile.joiner %>% 
  group_by(supertile.id.num) %>% 
  summarise(a = n()) %>% 
  ungroup() %>% 
  distinct(supertile.id.num, a) %>% 
  deframe()
```

```{r}
# Voronoi

# Voronoi estimation with tower locations as seeds
VOR.tower <- VOR_est(area = area, 
                     cellplan.combined = cellplan.combined, 
                     signal.strength.comb.dt = signal.strength.comb.dt, 
                     C.vec.df = C.vec.df, 
                     seed = "tower")
VOR.tower.est <- VOR.tower$seed.voronoi.final %>% 
  rename(u.VOR.tower = u.VOR)


# Voronoi estimation with cell locations + offset as seeds
VOR.offset <- VOR_est(area = area, 
                     cellplan.combined = cellplan.combined, 
                     signal.strength.comb.dt = signal.strength.comb.dt, 
                     C.vec.df = C.vec.df, 
                     seed = "cell.offset",
                     offset = 10) 
VOR.offset.est <- VOR.offset$seed.voronoi.final %>% 
  rename(u.VOR.offset = u.VOR)


# Voronoi estimation with cell hotpoint locations as seeds
VOR.hotpoint <- VOR_est(area = area, 
                        cellplan.combined = cellplan.combined, 
                        signal.strength.comb.dt = signal.strength.comb.dt, 
                        C.vec.df = C.vec.df, 
                        seed = "cell.hotpoint") 
VOR.hotpoint.est <- VOR.hotpoint$seed.voronoi.final %>% 
  rename(u.VOR.hotpoint = u.VOR)

# Voronoi estimation with cell barycenter locations as seeds
VOR.barycenter <- VOR_est(area = area, 
                        cellplan.combined = cellplan.combined, 
                        signal.strength.comb.dt = signal.strength.comb.dt, 
                        C.vec.df = C.vec.df, 
                        seed = "cell.barycenter") 
VOR.barycenter.est <- VOR.barycenter$seed.voronoi.final %>% 
  rename(u.VOR.barycenter = u.VOR)

VOR.tower$Voronoi.regions.plot
ggsave("Voronoi/tower.png", VOR.tower$Voronoi.regions.plot, device = "png")
VOR.offset$Voronoi.regions.plot
ggsave("Voronoi/offset.png", VOR.offset$Voronoi.regions.plot, device = "png")
VOR.hotpoint$Voronoi.regions.plot
ggsave("Voronoi/hotpoint.png", VOR.hotpoint$Voronoi.regions.plot, device = "png")
VOR.barycenter$Voronoi.regions.plot
ggsave("Voronoi/barycenter.png", VOR.barycenter$Voronoi.regions.plot, device = "png")


```

```{r}
SB.oracle.est <- EM_est(c.vec.dt = c.vec.dt, P.dt = P.star.oracle.dt.d, a.vec.dt = a.tile.dt, 
                        selected.range = 1,
                        n.iter = 1) %>% 
  dplyr::rename(tile.id = j, prior.SB.oracle = i.u, u.SB.oracle = u1)
```


```{r}
# a.tile.vec <- area$area.df$pop


# EM equal probability
EM.equal.est <- EM_est(c.vec.dt = c.vec.dt, P.dt = P.star.equal.dt, a.vec.dt = a.tile.dt, 
                       selected.range = c(1:10, 20, 50, seq(100, 200, 50)),
                       n.iter = 200) %>% 
  rename_with(.fn = ~gsub("u", "u.EM.equal", x = .x, fixed = T), 
              .cols = starts_with("u")) %>% 
  rename(tile.id = j, prior.EM.equal = i.u)

# EM oracle 
EM.oracle.est <- EM_est(c.vec.dt = c.vec.dt, P.dt = P.star.oracle.dt.d, a.vec.dt = a.tile.dt, 
                       selected.range = c(1:10, seq(20, 90, 10), seq(100, 200, 50)),
                       n.iter = 200) %>% 
  rename_with(.fn = ~gsub("u", "u.EM.oracle", x = .x, fixed = T), 
              .cols = starts_with("u")) %>% 
  rename(tile.id = j, prior.EM.oracle = i.u)

# EM.prior <- data.table(j = EM.equal.est$tile.id,
#                        u = EM.equal.est$u.EM.equal200)
# 
# 
# EM.equal.prior <- EM_est(c.vec.dt = c.vec.dt, P.dt = P.star.oracle.dt.d,
#                          a.vec.dt = EM.prior, 
#                          selected.range = c(1, 5, 100, 200, 300, 400, 500),
#                          n.iter = 500) %>% 
#   rename_with(.fn = ~gsub("u", "u.EM.oracle", x = .x, fixed = T), 
#               .cols = starts_with("u")) %>% 
#   rename(tile.id = j)


# check new EM function with old one 

# old <- SB_u_est_EM_mat(c.vec = c.vec,
#                        P.dt = P.star.oracle.dt,
#                        a.vec = a.tile.vec,
#                        n.iter = 100)
# 
# old.1 <- old %>%
#   dplyr::select(j, u0, u1, matches("97|98|99|100"))
# 
# new1 <- EM.oracle.est %>% 
#   dplyr::select(tile.id, u.EM.oracle1, matches("97|98|99|100"))
# 
# e <- left_join(old.1, new1, by = c("j" = "tile.id")) %>% 
#   mutate(diff.100 = u100 - u.EM.oracle100)


```

```{r}
# DF oracle

DF_est_iterated <- function(c.vec.dt, P.star.spm, a.supertile.vec, P.dt, DF.threshold = 1, selected.range.DF, n.iter.DF){
  
  c.vec <- c(c.vec.dt)$c

  DF.tiles <- data.table(j = as.numeric(names(a.supertile.helper)),
                         u = a.supertile.vec)
  keep <- data.table(j = as.numeric(names(a.supertile.helper)),
                     prior = a.supertile.vec)
  
  for(m.DF in 1:(n.iter.DF)){
    
    # time/iteration indication
    cat(format(Sys.time()), paste0("---- calculating u", m.DF), "----\n")

    # specify prior (A)
    U.spm <- .sparseDiagonal(n = length(a.supertile.vec), x = DF.tiles$u)

    # calculate DF
    Y <- P.star.spm %*% U.spm %*% t(P.star.spm)
    Y1 <- VCA::MPinv(Y) %*% (c.vec - P.star.spm %*% a.supertile.vec)
    u.unadj <- as.vector(U.spm %*% t(P.star.spm) %*% Y1 + a.supertile.vec)

    DF.tiles <- data.table(j = as.numeric(names(a.supertile.helper)),
                           u = u.unadj)
    # Transforming
    DF.tiles <- eval(parse(text = paste0("DF.tiles[, u := fifelse(u < (DF.threshold / m.DF), DF.threshold / m.DF, u)]")))

    # Renormalizing with 1 EM iteration
    u.dt <- EM_est(c.vec.dt = c.vec.dt,
                   P.dt = P.star.oracle.supertile.dt,
                   a.vec.dt = DF.tiles,
                   selected.range = 1,
                   n.iter = 1)
    setnames(u.dt, c("j", "u.prior", "u"))
    u.dt.final <- u.dt[, c("j", "u")]
    DF.tiles <- DF.tiles[, "j"]
    DF.tiles <- u.dt.final[DF.tiles, on = "j"]

    if(m.DF %in% selected.range.DF) {
      keep <- DF.tiles[keep, on = "j"]
      keep <- eval(parse(text = paste0("keep[, u", m.DF, ":= u]")))
      keep[, "u" := NULL]
    }
    
  }
  
  return(keep)
}




tm.DF.est <- system.time(
  {
    DF.oracle.est <- DF_est(c.vec.dt = c.vec.dt, 
                            P.star.spm = P.star.oracle.supertile.spm, 
                            a.supertile.vec = a.supertile.helper)
    DF.oracle.est.dt <- data.table(j = as.numeric(names(a.supertile.helper)),
                                   u = DF.oracle.est) %>%
      .[, u := fifelse(u < 1, 1, u)] # set negative values immediately to 0
    
    ## Renormalizing with EM and bringing estimate on tile.id level
    DF_EM.oracle.est <- EM_est(c.vec.dt = c.vec.dt, 
                               P.dt = P.star.oracle.supertile.dt, a.vec.dt = DF.oracle.est.dt,
                               selected.range = c(1:10, seq(20, 90, 10), seq(100, 200, 50)),
                               n.iter = 200) %>% 
      rename_with(.fn = ~gsub("u", "u.DF_EM.oracle", x = .x, fixed = T), 
                  .cols = starts_with("u")) %>% 
      rename(supertile.id.num = j, prior.DF_EM.oracle = i.u) %>%
      right_join(area$area.df, by = "supertile.id.num") %>% 
      group_by(supertile.id) %>% 
      mutate(across(starts_with("u"), ~ . / n())) %>% 
      ungroup() %>% 
      dplyr::select(tile.id, starts_with("u"))

  })


DF3_EM.oracle.est <- DF_est_iterated(c.vec.dt = c.vec.dt, 
                                     P.star.spm = P.star.oracle.supertile.spm, 
                                     a.supertile.vec = a.supertile.helper, 
                                     P.dt = P.star.oracle.supertile.dt, 
                                     DF.threshold = 1,
                                     selected.range = c(1:10, seq(20, 90, 10), seq(100, 200, 50)),
                                     n.iter.DF = 200) %>% 
  rename_with(.fn = ~gsub("u", "u.DF3_EM.oracle", x = .x, fixed = T), 
              .cols = starts_with("u")) %>% 
  rename(supertile.id.num = j, prior.DF_EM.oracle = prior) %>%
  right_join(area$area.df, by = "supertile.id.num") %>% 
  group_by(supertile.id) %>% 
  mutate(across(starts_with("u"), ~ . / n())) %>% 
  ungroup() %>% 
  dplyr::select(tile.id, starts_with("u"))

```



## Evaluation

```{r}
final.estimates.sf <- area$area.sf %>% 
  left_join(VOR.tower.est, by = "tile.id") %>% 
  left_join(VOR.offset.est, by = "tile.id") %>% 
  left_join(VOR.hotpoint.est, by = "tile.id") %>% 
  left_join(VOR.barycenter.est, by = "tile.id") %>% 
  left_join(SB.oracle.est, by = "tile.id") %>%
  left_join(EM.equal.est, by = "tile.id") %>%
  left_join(EM.oracle.est, by = "tile.id") %>% 
  left_join(DF_EM.oracle.est, by = "tile.id") %>% 
  left_join(DF2_EM.oracle.est, by = "tile.id") %>% 
  left_join(DF3_EM.oracle.est, by = "tile.id") 

final.estimates.df <- final.estimates.sf %>% 
  st_drop_geometry()

names.estimates <- final.estimates.sf %>% 
  # dplyr::select(pop, starts_with("u.")) %>% # all estimates
  dplyr::select(pop, matches("VOR|u.SB|u.EM.oracle200|u.DF_EM.oracle200|equal200")) %>% # only specific ones for mapping
  st_drop_geometry() %>% 
  names() 

maps.labels <- list("GTP  ", "VOR_t", "VOR_o", "VOR_h", "VOR_b", "SB   ", "EM_o  ", "EM_e  ", "DF   ")
  

# maps.estimation.density.limitless <- names.estimates %>% 
#   map(~map_density_limitless(data = final.estimates.sf, var = .x, label = .x)) %>% 
#   set_names(names.estimates)

# maps.estimation.density <- names.estimates %>% 
#   map(~map_density(data = final.estimates.sf, var = .x, label = .x)) %>% 
#   set_names(names.estimates)

max.maps <- final.estimates.sf %>% 
  st_drop_geometry() %>% 
  dplyr::select(tile.id, pop, matches("VOR|u.SB|oracle200|equal200")) %>% # only specific ones for mapping
  summarise_all(max) %>% 
  pivot_longer(cols = -tile.id, names_to = "estimator", values_to = "estimate")

breaks <- c(0, 2, 10, 20, 50, 100, 200, 500, 1000, Inf)
maps.input <- final.estimates.sf %>% 
  dplyr::select(tile.id, pop, matches("VOR|u.SB|oracle200|equal200")) %>% 
  mutate(across(c(pop, starts_with("u.")), ~cut(., breaks = breaks, dig.lab = 7, right = F)))
  # mutate(across(c(pop, starts_with("u.")), ~log10(. + 1)))



colors <- c("white", "light grey", "light blue", "blue", "light green", "yellow", "orange", "red", "#654321")

map_density <- function(data, var, label) {
  
  var.label <- paste(label)
  
  plot <- data %>% 
    
    ggplot() +
    geom_sf(aes_string(fill = var), color = "transparent") +
    # scico::scale_fill_scico(palette = "bilbao", limits = c(0, 3.48), direction = 1) +
    scale_fill_manual(values = colors, drop = F, name = label) +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank()) +
    theme_minimal()
  
  return(plot)
}


# plot <- maps.input %>% 
#     ggplot() +
#   geom_sf(aes(fill = pop), color = "transparent") +
#   scico::scale_fill_scico(palette = "bilbao", limits = c(0, 3.7), direction = 1) +
#   # scale_fill_fermenter(direction = 1, limits = c(0, 3.4), n.breaks = 7, palette = "RdBu") +
#     theme_minimal() +
#     theme(axis.title.x = element_blank(),
#           axis.text.x = element_blank(),
#           axis.ticks.x = element_blank(),
#           axis.title.y = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks.y = element_blank()) +
#     labs(title = var.label,
#          fill = "Estimate")
  

maps.estimation.density <- names.estimates %>%
  map2(., maps.labels, ~map_density(data = maps.input, var = .x, label = .y)) %>%
  set_names(names.estimates)

ggsave("Maps/pop.png", maps.estimation.density$pop, device = "png")
ggsave("Maps/u.VOR.tower.png", maps.estimation.density$u.VOR.tower, device = "png")
ggsave("Maps/u.VOR.offset.png", maps.estimation.density$u.VOR.offset, device = "png")
ggsave("Maps/u.VOR.hotpoint.png", maps.estimation.density$u.VOR.hotpoint, device = "png")
ggsave("Maps/u.VOR.barycenter.png", maps.estimation.density$u.VOR.barycenter, device = "png")
ggsave("Maps/u.SB.oracle.png", maps.estimation.density$u.SB.oracle, device = "png")
ggsave("Maps/u.EM.oracle200.png", maps.estimation.density$u.EM.oracle200, device = "png")
ggsave("Maps/u.EM.equal200.png", maps.estimation.density$u.EM.equal200, device = "png")
ggsave("Maps/u.DF_EM.oracle200.png", maps.estimation.density$u.DF_EM.oracle200, device = "png")


# grid arrange
```




```{r}
# KWD evaluation

rescale.factor <- 1

# area.2x2 <- area$area.sf %>% 
#   dplyr::select(tile.id, pop) %>% 
#   st_make_grid(cellsize = area$area.params[["base.tile.size"]] * rescale.factor)

kwd.helper.est <- final.estimates.sf %>% 
  # dplyr::select(tile.id, pop, starts_with("u.")) %>% 
  dplyr::select(tile.id, all_of(names.estimates)) %>%
  mutate(u.flat = mean(pop)) %>% 
  # aggregate(by = area.2x2, FUN = sum, join = st_contains) %>% 
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]])) %>% 
  st_drop_geometry()

coordinates <- kwd.helper.est %>% 
  dplyr::select(lon, lat) %>% 
  as.matrix()

weights <- kwd.helper.est %>% 
  dplyr::select(pop, matches("u.")) %>% 
  as.matrix()

kwd.final <- compareOneToMany(coordinates, weights, L = 3, recode = TRUE)
cat("runtime:", kwd.final$runtime, " distance:", kwd.final$distance, " nodes:", 
    kwd.final$nodes, "arcs:", kwd.final$arcs, "\n")

names.weights <- colnames(weights)[-1]
kwd.eval <- tibble(estimator = names.weights,
                   kwd = kwd.final$distance * rescale.factor) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 1.29)) %>%  # for L=3 within 1 percent 
  mutate(iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>%
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  group_by(kind) %>% 
  mutate(min.kwd.kind = min(kwd),
         kind.group = row_number() / max(row_number())) %>% # find minimum per estimator (for ordering help)
  ungroup() %>% 
  arrange(desc(min.kwd.kind), iteration) %>% 
  mutate(final.order = row_number()) %>% 
  mutate(estimator.new = factor(final.order, labels = estimator))

flat.ref <- round(as.numeric(kwd.eval[kwd.eval$estimator == "u.flat", "kwd"]), 2)

dodge <- position_dodge(width = 0.9)

(kwd.complete.plot <- kwd.eval %>% 
    filter(kind.group == 1,
           !str_detect(estimator, "flat")) %>% 
    ggplot(aes(x = estimator.new, y = kwd, fill = kind, alpha = kind.group)) + 
    geom_bar(stat = "identity", position = dodge) + 
    geom_errorbar(aes(ymin = kwd.lower.bound, ymax = kwd), position = dodge, width = 0.25) +
    geom_text(aes(x = estimator.new, y = kwd, label = round(kwd, 2)), 
              position = position_dodge(0.1), hjust = -0.1, color = "Black", size = 3) +
    scale_alpha(range = c(0.5, 1), 
                guide = F
                # labels = unique(kwd.eval$iteration)
                ) + # noch ändern
    scale_fill_ptol(guide = FALSE) +
    coord_flip() +
    labs(x = "", y = "KWD", 
         alpha = "Iteration", 
         subtitle = paste0("(Reference: Flat = ", flat.ref, ")")) + 
    theme(legend.position = "bottom"))

ggsave(filename = "kwd final/kwd.complete.1x1.plot.png", plot = kwd.complete.plot, device = "png")
kwd.fabio1x1 <- kwd.eval %>% 
  dplyr::select(estimator, kwd.upper.bound = kwd, kwd.lower.bound)
write.csv(kwd.fabio1x1, file = "kwd final/kwd.1x1.csv", row.names = F)
kwd.fabio2x2 <- kwd.eval.2x2 %>% 
  dplyr::select(estimator, kwd.upper.bound = kwd, kwd.lower.bound)
write.csv(kwd.fabio2x2, file = "kwd final/kwd.2x2.csv", row.names = F)
```


# kwd final 2x2

```{r}
rescale.factor <- 2

area.2x2 <- area$area.sf %>%
  dplyr::select(tile.id, pop) %>%
  st_make_grid(cellsize = area$area.params[["base.tile.size"]] * rescale.factor)

kwd.helper.est.2x2 <- final.estimates.sf %>% 
  # dplyr::select(tile.id, pop, starts_with("u.")) %>% 
  dplyr::select(tile.id, all_of(names.estimates)) %>%
  mutate(u.flat = mean(pop)) %>% 
  aggregate(by = area.2x2, FUN = sum, join = st_contains) %>%
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]])) %>% 
  st_drop_geometry()

coordinates.2x2 <- kwd.helper.est.2x2 %>% 
  dplyr::select(lon, lat) %>% 
  as.matrix()

weights.2x2 <- kwd.helper.est.2x2 %>% 
  dplyr::select(pop, matches("u.")) %>% 
  as.matrix()

kwd.final.2x2 <- compareOneToMany(coordinates.2x2, weights.2x2, L = 3, recode = TRUE)
cat("runtime:", kwd.final.2x2$runtime, " distance:", kwd.final.2x2$distance, " nodes:", 
    kwd.final.2x2$nodes, "arcs:", kwd.final.2x2$arcs, "\n")

names.weights <- colnames(weights.2x2)[-1]
kwd.eval.2x2 <- tibble(estimator = names.weights,
                       kwd = kwd.final.2x2$distance * rescale.factor) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 1.29)) %>%  # for L=3 within 1 percent 
  mutate(iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>%
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  group_by(kind) %>% 
  mutate(min.kwd.kind = min(kwd),
         kind.group = row_number() / max(row_number())) %>% # find minimum per estimator (for ordering help)
  ungroup() %>% 
  arrange(desc(min.kwd.kind), iteration) %>% 
  mutate(final.order = row_number()) %>% 
  mutate(estimator.new = factor(final.order, labels = estimator))

flat.ref.2x2 <- round(as.numeric(kwd.eval.2x2[kwd.eval.2x2$estimator == "u.flat", "kwd"]), 2)

dodge <- position_dodge(width = 0.9)

(kwd.complete.plot.2x2 <- kwd.eval.2x2 %>% 
    filter(kind.group == 1,
           !str_detect(estimator, "flat")) %>% 
    ggplot(aes(x = estimator.new, y = kwd, fill = kind, alpha = kind.group)) + 
    geom_bar(stat = "identity", position = dodge) + 
    geom_errorbar(aes(ymin = kwd.lower.bound, ymax = kwd), position = dodge, width = 0.25) +
    geom_text(aes(x = estimator.new, y = kwd, label = round(kwd, 2)), 
              position = position_dodge(0.1), hjust = -0.1, color = "Black", size = 3) +
    scale_alpha(range = c(0.5, 1), 
                guide = F
                # labels = unique(kwd.eval$iteration)
                ) + # noch ändern
    scale_fill_ptol(guide = FALSE) +
    coord_flip() +
    labs(x = "", y = "KWD", 
         alpha = "Iteration", 
         subtitle = paste0("(Reference: Flat = ", flat.ref.2x2, ")")) + 
    theme(legend.position = "bottom"))

ggsave(filename = "kwd final/kwd.complete.2x2.plot.png", plot = kwd.complete.plot.2x2, device = "png")
```


```{r}



(kwd.convergence <- kwd.eval %>% 
    filter((str_detect(kind, "u.EM.oracle") & iteration %in% c(1:10, seq(20, 90, 10), seq(100, 200, 50))) |
           (str_detect(kind, "DF") & iteration %in% c(1:10, 200))) %>% 
    ggplot(aes(x = estimator.new, y = kwd.2x2, fill = kind, alpha = kind.group)) + 
    geom_bar(stat = "identity", position = "dodge") + 
    geom_text(aes(x = estimator.new, y = kwd.2x2, label = round(kwd.2x2, 2)), 
              position = position_dodge(0.1), hjust = -0.1, color = "Black", size = 3) +
    scale_alpha(range = c(0.5, 1) 
                # labels = unique(kwd.eval$iteration)
                ) +
    scale_fill_ptol(guide = FALSE) +
    coord_flip() +
    labs(x = "", y = "KWD", alpha = "Iteration", title = "Estimator Comparison ~ KWD") + 
    theme(legend.position = "bottom"))


ggsave(filename = "kwd.convergence.png", plot = kwd.convergence, device = "png")


```


# kwd convergence

```{r}
# KWD evaluation

rescale.factor <- 2

area.2x2 <- area$area.sf %>%
  dplyr::select(tile.id, pop) %>%
  st_make_grid(cellsize = area$area.params[["base.tile.size"]] * rescale.factor)

kwd.helper.convergence <- final.estimates.sf %>%
  dplyr::select(tile.id, pop, contains("oracle"), contains("equal"), contains("DF")) %>%
  dplyr::select(tile.id, pop, matches("1|2|3|5|10|15|50|100|200")) %>%
  aggregate(by = area.2x2, FUN = sum, join = st_contains) %>%
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]])) %>%
  st_drop_geometry()

coordinates.2x2.convergence <- kwd.helper.convergence %>%
  dplyr::select(lon, lat) %>%
  as.matrix()

weights.2x2.convergence <- kwd.helper.convergence %>%
  dplyr::select(pop, matches("u.")) %>%
  as.matrix()

kwd.final.2x2.convergence <- compareOneToMany(coordinates.2x2.convergence, weights.2x2.convergence,
                                              L = 3, recode = TRUE)
cat("runtime:", kwd.final.2x2.convergence$runtime, " distance:", kwd.final.2x2.convergence$distance, " nodes:", kwd.final.2x2.convergence$nodes, " arcs:", kwd.final.2x2.convergence$arcs, "\n")


# ###### rescale 1
# rescale.factor <- 1
# 
# kwd.helper.convergence <- final.estimates.sf %>%
#   dplyr::select(tile.id, pop, contains("oracle")) %>%
#   dplyr::select(tile.id, pop, matches("1|2|3|5|10|15|50|100|200")) %>%
#   mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
#          lat = map_dbl(geometry, ~st_centroid(.x)[[2]])) %>%
#   st_drop_geometry()
# 
# coordinates.1x1.convergence <- kwd.helper.convergence %>%
#   dplyr::select(lon, lat) %>%
#   as.matrix()
# 
# weights.1x1.convergence <- kwd.helper.convergence %>%
#   dplyr::select(pop, matches("u.")) %>%
#   as.matrix()
# 
# kwd.final.convergence <- compareOneToMany(coordinates.1x1.convergence, weights.1x1.convergence,
#                                               L = 3, recode = TRUE)
# cat("runtime:", kwd.final.convergence$runtime, " distance:", kwd.final.convergence$distance, " nodes:", kwd.final.convergence$nodes, " arcs:", kwd.final.convergence$arcs, "\n")

names.weights <- colnames(weights.2x2.convergence)[-1]
kwd.eval.convergence <- tibble(estimator = names.weights,
                               kwd = kwd.final.2x2.convergence$distance * rescale.factor) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 1.29)) %>%  # for L=3 within 1 percent 
  mutate(iteration = str_extract(estimator, "[[:digit:]]+$"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>%
  mutate(kind = case_when(str_detect(estimator, "DF2") ~ "u.DF2_EM.oracle",
                          str_detect(estimator, "DF3") ~ "u.DF3_EM.oracle",
                          TRUE ~ kind)) %>% 
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(time.var = as.numeric(iteration) * 1,
         time.fix = case_when(str_detect(kind, "DF") ~ 3,
                              str_detect(kind, "u.EM") ~ 0)) %>%  # 11 min MP inverse
  mutate(time.final = (time.var + time.fix)) %>%
  group_by(kind) %>% 
  mutate(min.kwd.kind = min(kwd),
         kind.group = row_number() / max(row_number())) %>% # find minimum per estimator (for ordering help)
  ungroup() %>% 
  arrange(desc(min.kwd.kind), iteration) %>% 
  mutate(final.order = row_number()) %>% 
  mutate(estimator.new = factor(final.order, labels = estimator))

(kwd.convergence.plot.log.text <- kwd.eval.convergence %>% 
    dplyr::select(estimator, kwd, kwd.lower.bound, iteration, kind) %>% 
    ggplot(aes(x = iteration, y = kwd)) +
    geom_line(aes(color = kind)) +
    geom_point(aes(color = kind)) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = kind), alpha = 0.2) +
    geom_text_repel(aes(color = kind, label = round(kwd, 2)), size = 3, show.legend  = F) +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    scale_color_discrete(breaks = c("u.DF_EM.oracle", "u.DF2_EM.oracle", "u.DF3_EM.oracle", "u.EM.oracle", "u.EM.equal"), labels = c("DF", "DF2", "DF3", "EM_o", "EM_e")) +
    annotation_logticks(sides = "b") +
    labs(color = "Estimator",
         x = "Iteration",
         y = "KWD"))

(kwd.convergence.plot.log <- kwd.eval.convergence %>% 
    dplyr::select(estimator, kwd.1x1, kwd.lower.bound, iteration, kind) %>% 
    ggplot(aes(x = iteration, y = kwd.1x1)) +
    geom_line(aes(color = kind)) +
    geom_point(aes(color = kind)) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd.1x1, group = kind), alpha = 0.2) +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    scale_color_discrete(breaks = c("u.DF_EM.oracle", "u.EM.oracle"), labels = c("DF", "EM")) +
    annotation_logticks(sides = "b") +
    labs(color = "Estimator",
         x = "Iteration",
         y = "KWD"))

(kwd.convergence.plot <- kwd.eval.convergence %>% 
    dplyr::select(estimator, kwd.1x1, kwd.lower.bound, iteration, kind) %>% 
    ggplot(aes(x = iteration, y = kwd.1x1)) +
    geom_line(aes(color = kind)) +
    geom_point(aes(color = kind)) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd.1x1, group = kind), alpha = 0.2) +
    scale_color_discrete(breaks = c("u.DF_EM.oracle", "u.EM.oracle"), labels = c("DF", "EM")) +
    labs(color = "Estimator",
         x = "Iteration",
         y = "KWD"))

ggsave("kwd convergence/kwd.1x1.linear.png", kwd.convergence.plot, device = "png")
ggsave("kwd convergence/kwd.1x1.log10.png", kwd.convergence.plot.log, device = "png")
ggsave("kwd convergence/kwd.2x2.log10.labels.DF3.png", kwd.convergence.plot.log.text, device = "png")


(time.convergence.plot <- kwd.eval.convergence %>% 
    dplyr::select(estimator, time.final, iteration, kind) %>% 
    ggplot() +
    geom_line(aes(x = iteration, y = time.final, color = kind)) +
    geom_point(aes(x = iteration, y = time.final, color = kind)) +
    scale_color_discrete(breaks = c("u.DF_EM.oracle", "u.EM.oracle"), labels = c("DF", "EM")) +
    labs(color = "Estimator",
         x = "Iteration",
         y = "Time in seconds"))
  
ggsave("kwd convergence/time.png", time.convergence.plot, device = "png")

```



```{r}
# (p1 <- kwd.eval %>% 
#   ggplot() +
#   geom_line(aes(x = iteration.ord, y = kwd.4x4, color = kind, group = kind), size = 1) +
#   geom_point(aes(x = iteration.ord, y = kwd.4x4, color = kind, group = kind)) +
#   geom_text(aes(label = round(kwd.4x4, 3), x = iteration.ord, y = kwd.4x4 + 0.018, color = kind)) +
#   labs(title = "Comparing KWD performance based on estimator (flat prior) and iterations",
#        subtitle = "x-scale is for visual purposes NOT scaled proportionally",
#        x = "Iteration",
#        y = "KWD 4x4 (rescaled)",
#        color = "Estimator"))
# 
# # ggsave(filename = "C:/Users/Marco/Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/estimation plots/kwd.EM.DF.png", plot = p1, device = "png")
# 
# (p2 <- kwd.eval %>% 
#   ggplot() +
#   geom_line(aes(x = as.numeric(iteration), y = time.final, color = kind, group = kind)) +
#   geom_hline(yintercept = 11, linetype = "dotted") +
#   annotate("text", x = 600, y = 15, label = "Fixed time cost of ca. 11 min. for MP inverse calculation") +
#   labs(title = "Comparing computation time based on estimator (flat prior) and iterations",
#        subtitle = "Each iteration takes ca. 7-9 seconds",
#        x = "Iteration",
#        y = "Time in minutes",
#        color = "Estimator"))

# ggsave(filename = "C:/Users/Marco/Vysoká škola ekonomická v Praze/Tony Wei Tse Hung - YAY/estimation plots/time.EM.DF.png", plot = p2, device = "png")
```




```{r}

names.order.estimator <- c("u.flat", "u.VOR.tower", "u.VOR.offset", "u.VOR.hotpoint", "u.VOR.barycenter",
                           "u.SB.oracle", "u.EM.equal", "u.EM.oracle", "u.DF_EM.oracle")
names.order.estimator.diff <- paste0("diff_", names.order.estimator)

rescale.factor.list <- list(area.2x2 = 2, 
                            area.4x4 = 4, 
                            area.8x8 = 8)

area.rescaled.grid <- map(rescale.factor.list, 
            ~st_make_grid(area$area.sf, cellsize = area$area.params[["base.tile.size"]] * .x))


mse.helper.est <- final.estimates.sf %>% 
  dplyr::select(tile.id, pop, starts_with("u.")) %>% 
  mutate(u.flat = mean(pop))

mse.est <- map(area.rescaled.grid, ~aggregate(mse.helper.est, by = .x, FUN = mean, join = st_contains)) %>% 
  map(~mutate(., lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
              lat = map_dbl(geometry, ~st_centroid(.x)[[2]]))) %>% 
  map(~st_drop_geometry(.)) %>% 
  map(~dplyr::select(., -lon, -lat))

area.1x1 <- final.estimates.df %>% 
  dplyr::select(tile.id, pop, starts_with("u.")) %>% 
  mutate(u.flat = mean(pop))

mse.est[["area.1x1"]] <- area.1x1

point <- mse.est %>% 
  map(~mutate(., tile.id.rescaled = row_number())) %>% 
  map(~dplyr::select(., tile.id.rescaled, pop, starts_with("u."))) %>% 
  map_dfr(~pivot_longer(., cols = -c(tile.id.rescaled, pop), 
                        names_to = "estimator", values_to = "estimate"), .id = "scale") %>% 
  mutate(rescale.factor = as.numeric(str_extract(scale, "[[:digit:]]")),
         iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>% 
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(estimator.ordered = factor(kind, levels = names.order.estimator))



  complete <- point %>% 
    filter(estimator %in% c("u.EM.oracle10")) %>% 
    ggplot(aes(x = pop, y = estimate)) +
    geom_pointdensity(size = 0.4) +
    scale_color_viridis() +
    geom_abline(intercept = 0 , slope = 1, linetype = "dotted") +
    # geom_density2d(color = "black") + 
    # lims(x = c(0, 5), y = c(0, 100)) +
    facet_wrap(vars(scale)) +
    labs(title = paste(estimator.name, "joint density plot"),
         subtitle = "Mind the axis limits")
  
  zoom.xy <- point %>% 
    filter(estimator %in% c("u.EM.oracle10")) %>% 
    group_split(scale) %>% 
    map(~ggplot(., aes(x = pop, y = estimate)) +
          geom_pointdensity(size = 0.4) +
          scale_color_viridis() +
          geom_abline(intercept = 0, slope = 1, linetype = "dotted") +
          lims(x = c(0, 5), y = c(0, 5)) +
          labs(title = "Zoom on x and y axis") + 
          facet_wrap(vars(scale)))
  
  d <- arrangeGrob(zoom.xy[[1]], zoom.xy[[2]], zoom.xy[[3]], zoom.xy[[4]],
                   layout_matrix = rbind(c(1, 2),
                                         c(3, 4)))
  ggsave("2d_density/example.png", d, device = "png")
                   

scatter.names <- c("u.EM.oracle1", "u.EM.oracle10", "u.EM.oracle100", "u.EM.oracle200",
                   "u.VOR.barycenter", "u.VOR.tower")

scatter.density.plots <- scatter.names %>% 
  map(~scatter_density(point, estimator.name = .x)) %>%
  set_names(scatter.names)

ggsave("2d_density/u.EM.oracle1.density.png", scatter.density.plots$u.EM.oracle1, device = "png")
ggsave("2d_density/u.EM.oracle10.density.png", scatter.density.plots$u.EM.oracle10, device = "png")
ggsave("2d_density/u.EM.oracle100.density.png", scatter.density.plots$u.EM.oracle100, device = "png")
ggsave("2d_density/u.EM.oracle200.density.png", scatter.density.plots$u.EM.oracle200, device = "png")
ggsave("2d_density/u.VOR.barycenter.png", scatter.density.plots$u.VOR.barycenter, device = "png")
ggsave("2d_density/u.VOR.tower.png", scatter.density.plots$u.VOR.tower, device = "png")


# e <- d %>% 
#   ggplot() +
#   stat_smooth(aes(x = pop, y = estimate, color = as.character(rescale.factor)), method = "loess", se = F) +
#   scale_x_continuous(limits = c(0, max(d$pop))) +
#   scale_y_continuous(limits = c(0, max(d$pop))) +
#   # geom_point(aes(x = pop, y = estimate, color = scale)) +
#   geom_abline(intercept = 0 , slope = 1, linetype = "dotted") +
#   facet_wrap(vars(estimator.ordered, iteration)) +
#   labs(title = "Comparing estimated densities with true density",
#        subtitle = "Mean aggregation per rescale, linear model smoother 'y ~ x",
#        x = "True Population per Tile",
#        y = "Estimated Population per Tile",
#        color = "Rescaling Factor")

ggsave("density.compare.scales.png", e)


```


```{r}
diff <- mse.est %>% 
  map(~mutate(., across(starts_with("u"), ~sqrt((.x - pop)^2), .names = "diff_{.col}"))) %>% 
  map(~dplyr::select(., tile.id.rescaled, pop, starts_with("diff_"))) %>% 
  map_dfr(~pivot_longer(., cols = -c(tile.id.rescaled, pop), 
                        names_to = "estimator", values_to = "estimate"), .id = "scale") %>% 
  mutate(rescale.factor = as.numeric(str_extract(scale, "[[:digit:]]")),
         iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>% 
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(estimator.ordered = factor(kind, levels = names.order.estimator.diff))
```



# cdf density plot

```{r}
names.estimates <- final.estimates.df %>% 
  # dplyr::select(pop, starts_with("u.")) %>% # all estimates
  dplyr::select(pop, matches("VOR|u.SB|oracle200")) %>% # only specific ones for mapping
  names() 
 
  custom_ecdf_prep <- function(data) {
    dat <- data %>% 
      mutate(pop.plot = values + 1) %>%  
      arrange(pop.plot) %>%  
      mutate(prob = 1 / n()) %>%  
      mutate(cum.prob = cumsum(prob)) %>%  
      mutate(cum.prob.comp = 1 - cum.prob) %>%  
      mutate(log10.cum.prob.comp = log10(cum.prob.comp)) %>% 
      mutate(log10.pop = log10(pop.plot)) %>%  
      mutate(cum.prob.comp = 1 - cum.prob)
    
    return(dat)
  }


cdf.compare <- final.estimates.df %>% 
  dplyr::select(tile.id, all_of(names.estimates)) %>% 
  pivot_longer(cols = -tile.id, names_to = "estimates", values_to = "values") %>% 
  split(.$estimates) %>% 
  map(~custom_ecdf_prep(.)) %>% 
  map(~dplyr::select(., cum.prob.comp, pop.plot)) %>%
  map(~mutate(., cum.prob.comp = round(cum.prob.comp, 3))) %>% # effective plot sample --> faster plotting excluding overplot
  map_dfr(~distinct(.), .id = "type")
  

(ECCDF.pop.plot <- cdf.compare %>% 
    ggplot() + 
    geom_line(aes(x = pop.plot, y = cum.prob.comp,
                  color = type), size = 1) + 
    scale_color_ptol() + 
    scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    annotation_logticks(sides = "lb") +
    labs(title = "ECCDF of estimators and GTP", y = "log10(ECCDF)", x = "log10(Mobile phones)",  
         colour = "") +
    theme(legend.position = "bottom"))
  
ggsave("type.ecdf.png", ECCDF.pop.plot, device = "png")

# ECDF.pop.plot <- ECDF.df %>%   
  #   ggplot() + 
  #   geom_point(aes(x = pop.plot, y = cum.prob.comp,
  #                  color = type
  #                  )) + 
  #   scale_color_ptol() +
  #   xlim(0, 30) +
  #   labs(title = "", y = "", x = "") +
  #   theme(legend.position = "none",
  #         plot.margin = unit(c(-0.5, 0, 0, -0.5), "cm")) 
  
  
  combined <- ECCDF.pop.plot +
    annotation_custom(ggplotGrob(ECDF.pop.plot), 
                      xmin = 0, xmax = 1.5, 
                      ymin = min(ECCDF.df$log10.cum.prob.comp, na.rm = T), ymax = -1.5)
  
```

Input: a vector p whose elements sum to unity, and a scalar quantization parameter n

Output: a vector p_out of the same length of p whose elements sum to unity and are integer multiples of 1/n (possibly zero). The number of non-zero elements of p_out is <= n


1. Check that the input vector sum to unity (up to tolerance value 'eps', e.g. 'eps=1e-10'.

if abs(sum(p)-1.0) > eps, error('ERROR: Input vector does not sum to unity! \n'); end 

2. Let Kp denote the number of non-zero elements of p

3. If Kp==1, then p_out is the same as p. End

4. If Kp==2, then there are only 2 non-zero elements equal to x and 1-x for some continuous x. Then simply round x to the nearest multiple of 1/n 
x_round = round(x*n)/n;
and replace the two values with x_round and 1-x_round

4. If Kp>2, then sort the elements of p, take the first (largest) n elements and set all others to zero. 
Then round the largest n elements independently.
Sum the rounded elements: 
	*) if the sum of rounded elements equal unity, you are done. 
	*) if the sum of rounded elements is higher than unity and is equal 1 + m/n, (m=1,2...) reduce by 1/n the m LARGEST elements.
	*) if the sum of rounded elements is lower than unity and is equal to 1 - m/n, (m=1,2...) increase by 1/n the m SMALLEST elements.

5. Check again that the output vector sum to unity 
```{r}

n = 8
multiple <- 1 / n

P.star.transformed.helper <- P.long.df %>% 
  mutate(pij.new = case_when(pij > 0 ~ 1,
                             pij <= 0 ~ 0)) %>% 
  group_by(tile.id.num) %>% 
  mutate(Kp = sum(pij.new)) %>% 
  ungroup() %>% 
  mutate(Kp.kind = case_when(Kp == 1 ~ "1",
                             Kp == 2 ~ "2",
                             Kp > 3 ~ "More than 2"))

P.star.1 <- P.star.transformed.helper %>% 
  filter(Kp.kind == "1") %>% 
  mutate(pij.final = 1)

P.star.2 <- P.star.transformed.helper %>%
  filter(Kp.kind == "2") %>% 
  group_by(tile.id.num) %>% 
  mutate(max.pij = max(pij),
         min.pij = min(pij)) %>%
  ungroup() %>% 
  mutate(pij.final = case_when(pij == max.pij ~ round(pij / multiple) * multiple, # pij.final sums up to 1 per tild.id.num
                               pij == min.pij ~ (1 - round(max.pij / multiple) * multiple))) 
  

P.star.3 <- P.star.transformed.helper %>%
  filter(Kp.kind == "More than 2") %>% 
  group_by(tile.id.num) %>% 
  mutate(rank = dense_rank(desc(pij))) %>% 
  ungroup() %>%
  filter(rank <= n) %>% 
  mutate(pij.im = round(pij / multiple) * multiple)
  

d <- P.star.3 %>% 
  dplyr::select(tile.id.num, cell, pij, rank, pij.im) %>% 
  group_by(tile.id.num) %>% 
  mutate(pij.final = case_when(sum(pij.im) == 1 ~ pij.im,
                               sum(pij.im) < 1 ~ (1 - sum(pij.im)) / n ,
                               sum(pij.im) > 1 ~ (sum(pij.im) - 1) / n)) %>% 
  mutate(pij.final = case_when(sum(pij.im) == 1 ~ pij.final,
                               sum(pij.im) < 1 ~ (1 - sum(pij.im)) / n ,
                               sum(pij.im) > 1 ~ (sum(pij.im) - 1) / n))







  mutate(pij = 1) %>% # same prob for all non-zero relationships
  dplyr::select(i = cell.num, j = tile.id.num, pij) %>%
  # dplyr::select(cell.num, tile.id.num, pij) %>%
  group_by(j) %>% 
  # mutate(pij = smart.round(pij / sum(pij), 3)) %>% 
  mutate(pij = pij / sum(pij)) %>%
  ungroup() %>% 
  as.data.table()
```

# new p equal algorithm



