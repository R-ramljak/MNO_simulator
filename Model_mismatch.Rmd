---
title: "Model mismatch"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: show
    code_download: true
    theme: sandstone
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: yes
---

```{r setup, message=FALSE}
# Data manipulation
library(tidyverse)
library(data.table) 

# Spatial operations
library(sf)
library(raster)
library(stars)

# Matrix operations
library(Matrix)

# MNO data handling and propagation model setup
# Credits to Prof. Martijn Tennekes https://github.com/mtennekes/mobloc
library(mobloc)

# Comparison of 2d histograms (Kantorovitch Wasserstein distance a.k.a. Earth Movers distance)
# Credits to Prof. Stefano Gualandi https://cran.r-project.org/web/packages/SpatialKWD/SpatialKWD.pdf
library(SpatialKWD)

# Output organisation and plotting support
library(ggthemes)
library(viridis)
library(ggrepel)
library(ggpointdensity)
library(scattermore)
library(grid)
library(gridExtra)
library(knitr)
library(DT)

# seed for reproducibility
set.seed(42)


# Loading Custom functions
source("pipeline functions.R")

# Load toyworld objects 
area <- readRDS("workflow_objects/area.rds")
cellplans.list <- readRDS("workflow_objects/cellplans.list.rds")
gen.model.objects <- readRDS("workflow_objects/gen.model.objects.rds")
```

## Model mismatch techniques

### Random noise implementation

```{r noise-implementation}


# define the number of bits --> final number of levels are 2^n + 1
noise.expression <- c(no_03 = "runif(min = -3, max = 3",
                      # no_06 = "runif(min = -6, max = 6",
                      # no_09 = "runif(min = -9, max = 9",
                      # no_12 = "runif(min = -12, max = 12",
                      # no_15 = "runif(min = -15, max = 15",
                      # no_18 = "runif(min = -18, max = 18",
                      no_21 = "runif(min = -21, max = 21",
                      no_true = "runif(min = 0, max = 0")

noise.expression.wo.true <- names(noise.expression)[!names(noise.expression) == ("no_true")]
noise.expression.only.true <- names(noise.expression)[names(noise.expression) == ("no_true")]


noise_mag <- function(x, expression, digits) {
  
  n <- length(x)
  
  expression.comp <- paste0(expression, ", n = ", n, ")")
    
  amount <- eval(parse(text = expression.comp))
  
  final <- x + round(amount, digits = digits)
  
  return(final)
  
  
}

noise_mutate <- function(df, noise.expression, digits) {
  
  mutate(df, "dBm.noise.{noise.expression}" := noise_mag(x = dBm, expression = noise.expression, digits = digits))
}


P.long.noise.df.helper <- cellplans.list %>% 
  map(~mutate(.x$signal.strength.comb.dt, cell.kind = substr(cell, 1, 2))) %>% 
  map2(., cellplans.list, ~left_join(.x, .y$param.df, by = "cell.kind")) %>% 
  map_dfr(~dplyr::rename(., sig_d_th = dominance.th), .id = "network.kind") %>% 
  group_by(network.kind)

set.seed(222)

P.long.noise.complete.df <- noise.expression %>% 
  map(~noise_mutate(df = P.long.noise.df.helper, noise.expression = .x, digits = 2)) %>% 
  map(~ungroup(.)) %>% 
  map2(., names(noise.expression), ~rename(.x, !!.y := starts_with("dBm.noise."))) %>% 
  map_at(noise.expression.wo.true, ~dplyr::select(., starts_with("no_"))) %>%
  bind_cols() %>% 
  pivot_longer(cols = starts_with("no_"), names_to = "noise.level", values_to = "noise.mag") %>% 
  split(list(.$network.kind, .$noise.level)) %>% 
  map(~mutate(., s.mismatch.mag = db2s(noise.mag, midpoint, steepness)))

names.network.noise <- names(P.long.noise.complete.df)

P.long.noise.df <- P.long.noise.complete.df %>% 
  map(~filter(., !s.mismatch.mag < 0.05)) %>% # define minimum threshold 
  map(~mutate(., pij = con_llh_sens_custom(., "s.mismatch.mag", digits = 3)))

# Only relevant for supertiles

  # map(~mutate(., supertile.id = create_supertile_index(., elements = c("tile.id.chr", "cell.chr", "pij", "a")))) %>% 
  # map(~mutate(., supertile.id.chr = as.numeric(supertile.id))) %>%
  # map(~mutate(., supertile.id.fac = factor(supertile.id.chr))) %>% 
  # map(~mutate(., supertile.id.num = as.numeric(supertile.id))) %>% 
  # map(~dplyr::select(., -supertile.id)) %>% 
  # map2(., paste0("supertile.id.chr_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.chr"))) %>% 
  # map2(., paste0("supertile.id.fac_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.fac"))) %>% 
  # map2(., paste0("supertile.id.num_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.num")))
  
# saveRDS(P.long.noise.df, "workflow_objects/P.long.noise.df.rds")     
```

```{r}
# noise on the dBm scale
order.levels.noise <- c(noise.expression.only.true, noise.expression.wo.true)
dense.names.noise <- names(P.long.noise.complete.df) %>% 
  str_subset("cellplan.1") 

(dBm.plot.ME <- P.long.noise.complete.df %>%
  magrittr::extract(dense.names.noise) %>% 
  map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, noise.mag, noise.level)) %>% 
  filter(cell == ("ME.77.C.2")) %>% 
  mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
  left_join(area$area.sf, by = "tile.id.num") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = noise.mag), color = "transparent") +
  scale_fill_viridis(na.value = "transparent") +
  facet_wrap(vars(noise.level), ncol = 4) +
  coord_sf() +
  labs(title = "Meso noise on the dBm scale without minimum threshold", 
       color = "dBm", fill = "dBm", x = "", y = "") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "bottom"))
# ggsave("workflow_objects/noise.dBm.plot.ME.png", dBm.plot.ME, device = "png")
```

```{r}
# noise on the signal dominance scale

(dom.plot.ME <- P.long.noise.df %>% 
   magrittr::extract(dense.names.noise) %>% 
  map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, s.mismatch.mag, noise.level)) %>% 
  filter(cell == ("ME.77.C.2")) %>% 
  mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
  left_join(area$area.sf, by = "tile.id.num") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = s.mismatch.mag), color = "transparent") +
  scale_fill_viridis(na.value = "transparent") +
  facet_wrap(vars(noise.level), ncol = 4) +
  coord_sf() +
  labs(title = "Meso noise on the dominance scale with minimum threshold", 
       color = "Signal\ndominance", fill = "Signal\ndominance", x = "", y = "") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "bottom"))

# ggsave("workflow_objects/noise.dom.plot.ME.png", dom.plot.ME, device = "png")
```

### Quantization

```{r}
# define the number of bits --> final number of levels are 2^n + 1

quant.levels <- c(quant_00 = 0,
                  # quant_01 = 1,
                  # quant_02 = 2,
                  quant_03 = 3,
                  # quant_04 = 4,
                  # quant_05 = 5,
                  # quant_10 = 10,
                  quant_true = 0) # last version is just a placeholder, the "0" is meaningless

quant.levels.wo.true <- names(quant.levels)[!names(quant.levels) == ("quant_true")]
quant.levels.only.true <- names(quant.levels)[names(quant.levels) == ("quant_true")]



quant_mutate <- function(df, n) {
  mutate(df, "s.quant.{n}" := quantize_mag(x = s, n = n))
}


P.long.quant.df.helper <- cellplans.list %>% 
  map(~mutate(.x$signal.strength.comb.dt, cell.kind = substr(cell, 1, 2))) %>% 
  map2(., cellplans.list, ~left_join(.x, .y$param.df, by = "cell.kind")) %>% 
  map_dfr(~dplyr::rename(., sig_d_th = dominance.th), .id = "network.kind") %>% 
  group_by(network.kind, cell.kind) 

P.long.quant.complete.df <- quant.levels %>% 
  map(~quant_mutate(df = P.long.quant.df.helper, n = .x)) %>% 
  map(ungroup) %>% 
  map_at(quant.levels.only.true, ~mutate(., s.quant.true = s)) %>% 
  map_at(quant.levels.only.true, ~dplyr::select(., -s.quant.0)) %>% 
  map2(., names(quant.levels), ~rename(.x, !!.y := starts_with("s.quant."))) %>% 
  map_at(quant.levels.wo.true, ~dplyr::select(., starts_with("quant_"))) %>%
  bind_cols() %>% 
  pivot_longer(cols = starts_with("quant_"), names_to = "quant.level", values_to = "quant.mag") %>% 
  split(list(.$network.kind, .$quant.level))
  
names.network.quant <- names(P.long.quant.complete.df)

P.long.quant.df <- P.long.quant.complete.df %>% 
  map(~filter(., !quant.mag < 0.05)) %>% # define minimum threshold 
  map(~mutate(., pij = con_llh_sens_custom(., "quant.mag", digits = 3)))

# Only relevant for supertiles

  # map(~mutate(., supertile.id = create_supertile_index(., elements = c("tile.id.chr", "cell.chr", "pij", "a")))) %>% 
  # map(~mutate(., supertile.id.chr = as.numeric(supertile.id))) %>%
  # map(~mutate(., supertile.id.fac = factor(supertile.id.chr))) %>% 
  # map(~mutate(., supertile.id.num = as.numeric(supertile.id))) %>% 
  # map(~dplyr::select(., -supertile.id)) %>% 
  # map2(., paste0("supertile.id.chr_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.chr"))) %>% 
  # map2(., paste0("supertile.id.fac_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.fac"))) %>% 
  # map2(., paste0("supertile.id.num_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.num")))

# saveRDS(P.long.quant.df, "workflow_objects/P.long.quant.df.rds")  

```

```{r}
# quantization on the dominance scale without threshold
order.levels.quant <- c(quant.levels.only.true, rev(quant.levels.wo.true))
dense.names.quant <- names(P.long.quant.complete.df) %>% 
  str_subset("cellplan.1") 

(dom.plot.ME <- P.long.quant.complete.df %>% 
    magrittr::extract(dense.names.quant) %>% 
    map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, quant.mag, quant.level)) %>% 
    filter(cell == ("ME.77.C.2")) %>% 
    mutate(quant.level = factor(quant.level, levels = order.levels.quant)) %>% 
    left_join(area$area.sf, by = "tile.id.num") %>% 
    st_as_sf() %>% 
    ggplot() +
    geom_sf(aes(fill = quant.mag), color = "transparent") +
    scale_fill_viridis(na.value = "transparent") +
    facet_wrap(vars(quant.level), ncol = 4) +
    coord_sf() +
    labs(title = "Meso quantization on the dominance scale without minimum threshold", 
         color = "Signal\ndominance", fill = "Signal\ndominance", x = "", y = "") +
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.x = element_blank(),
          axis.ticks.y = element_blank(),
          legend.position = "bottom"))
# ggsave("workflow_objects/quant.dom.plot.ME.wo.th.png", dom.plot.ME, device = "png")
```

```{r}
# quantization on the dominance scale with threshold

(dom.plot.ME.th <- P.long.quant.df %>% 
   magrittr::extract(dense.names.quant) %>% 
   map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, quant.mag, quant.level)) %>% 
   filter(cell == ("ME.77.C.2")) %>% 
   mutate(quant.level = factor(quant.level, levels = order.levels.quant)) %>% 
   left_join(area$area.sf, by = "tile.id.num") %>% 
   st_as_sf() %>% 
   ggplot() +
   geom_sf(aes(fill = quant.mag), color = "transparent") +
   scale_fill_viridis(na.value = "transparent") +
   facet_wrap(vars(quant.level), ncol = 4) +
   coord_sf() +
   labs(title = "Meso quantization on the dominance scale with minimum threshold", 
        color = "Signal\ndominance", fill = "Signal\ndominance", x = "", y = "") +
   theme(axis.text.x = element_blank(),
         axis.text.y = element_blank(),
         axis.ticks.x = element_blank(),
         axis.ticks.y = element_blank(),
         legend.position = "bottom"))
# ggsave("workflow_objects/quant.dom.plot.ME.w.th.png", dom.plot.ME.th, device = "png")
```

```{r}
cell.kind.unique <- n_distinct(param.df$cell.kind)
range.total <- rep(seq(10, 20000, by = 10), cell.kind.unique)
length.range.total <- rep(length(range.total) / cell.kind.unique, cell.kind.unique)

# use the helpers to construct plot dataframe and join with the input params
df <- tibble(cell.kind = factor(rep(param.df$cell.kind, length.range.total)),
             distance = range.total) %>% 
  left_join(param.df, by = "cell.kind") %>% 
  mutate(dBm = W2dBm(W)) %>% 
  mutate(distance.log10 = log10(distance)) %>% 
  mutate(dBm = distance2dB(distance, ple, W)) %>% 
  mutate(s = db2s(dBm, 
                  midpoint = midpoint, 
                  steepness = steepness))

### theoretical quantization vs true
new.df.theo.vars <- quant.levels %>% 
  map(~quant_mutate(df = df, n = .x)) %>% 
  map_at(quant.levels.only.true, ~mutate(., s.quant.true = s)) %>% 
  map_at(quant.levels.only.true, ~dplyr::select(., -s.quant.0)) %>% 
  map2(., names(quant.levels), ~rename(.x, !!.y := starts_with("s.quant."))) %>% 
  map_at(quant.levels.wo.true, ~dplyr::select(., starts_with("quant_"))) %>%
  bind_cols() %>% 
  pivot_longer(cols = starts_with("quant_"), names_to = "quant.level", values_to = "quant.mag") %>% 
  mutate(below.dominance.th = case_when(quant.mag >= 0.05 ~ "Above", 
                                        quant.mag < 0.05 ~ "Below"))


(theo.quant.plot <- new.df.theo.vars %>% 
  # filter(quant.level == "quant_true") %>% 
  ggplot() +
  # geom_point(aes(x = s, y = quant.mag, color = quant.level, group = quant.level))
  geom_line(aes(x = s, y = quant.mag, 
                color = quant.level), 
            size = 1) +
  facet_wrap(vars(quant.level), ncol = 4) +
  labs(x = "True signal dominance", 
       y = "Quantized signal dominance",
       color = "Quant. Version"))
# ggsave("workflow_objects//theo.quant.plot.png", theo.quant.plot, device = "png")
```

## Estimation 

### With supertiles

```{r estimation-input-parameters}
# ## estimation
# 
# P.long.mismatch.complete <- c(P.long.noise.df, P.long.quant.df) %>% 
#   discard(str_detect(names(.), "quant_true"))
# mismatch.versions <- names(P.long.mismatch.complete)
# 
# 
# supertile.joiner.prior <- P.long.mismatch.complete %>% 
#   map(., ~right_join(.x, area$area.df, 
#                      by = c("tile.id.num", "tile.id.fac", "tile.id.chr", "a"))) %>% 
#   map(~dplyr::select(., tile.id.num, a, contains("supertile.id.num"))) %>%
#   map(distinct) %>% 
#   map(~arrange(., tile.id.num)) 
# 
# supertile.joiner <- supertile.joiner.prior %>% 
#   map(~dplyr::select(., tile.id.num, contains("supertile.id.num")))
# 
# 
# ### supertile helper
# P.star.supertile.helper <- P.long.mismatch.complete %>%
#   map(~dplyr::select(., contains("supertile.id"), contains("cell"), pij)) %>% 
#   map(distinct) %>% 
#   map(~arrange(., cell.num))
# 
# 
# ### datatable versions
# P.star.matrices.dt <- P.star.supertile.helper %>%
#   map(~dplyr::select(., i = cell.num, contains("supertile.id.num"), pij)) %>% 
#   map(~rename(., j = contains("supertile.id.num"))) %>% 
#   map(as.data.table)
# 
# 
# ### spm versions
# P.star.matrices.spm <- P.star.supertile.helper %>%
#   map(~dplyr::select(., i = cell.num, contains("supertile.id.num"), x = pij)) %>% 
#   map(~rename(., j = contains("supertile.id.num"))) %>% 
#   map(~sparseMatrix(i = .$i, j = .$j, x = .$x))
# 
# 
# ### prior vector versions
# a.tile.helper <- supertile.joiner.prior %>% 
#   map(~dplyr::select(., contains("supertile.id.num"), a)) %>% 
#   map(~group_by(., across(contains("supertile.id.num")))) %>% 
#   map(~summarise(., a = sum(a))) %>% # uniform vector of number of normal tiles
#   map(drop_na) # uncovered tiles
# 
# a.tile.vec <- a.tile.helper %>% 
#   map(deframe)
# 
# a.tile.dt <- a.tile.helper %>% 
#   map(~dplyr::select(., j = contains("supertile.id.num"), u = a)) %>% 
#   map(as.data.table)
# 
# ### C vector, adding antennas that have 0 phones to complete the vector, arranging it according to the antenna.ID and saving as vector
# c.vec <- P.long.complete.df %>% 
#   map(~distinct(., cell.num, phones.sum)) %>% 
#   map2(., cellplans.list, ~right_join(.x, .y$cellplan.combined.df, by = "cell.num")) %>% 
#   map(~mutate(., phones.sum = case_when(is.na(phones.sum) ~ 0,
#                                 TRUE ~ phones.sum))) %>% 
#   map(~arrange(., cell.num)) %>% 
#   rep(., length(mismatch.versions) / length(.))
# 
# # define c-vector in datatable version
# c.vec.dt <- map(c.vec, ~data.table(i = .x$cell.num,
#                                    c = .x$phones.sum))
# 
# n.iter.MLE = 200
```

### Without supertiles

```{r}
## estimation
P.long.mismatch.complete <- c(P.long.noise.df, P.long.quant.df) %>% 
  discard(str_detect(names(.), "quant_true"))
mismatch.versions <- names(P.long.mismatch.complete)


### datatable versions
P.star.matrices.dt <- P.long.mismatch.complete %>%
  map(~arrange(., cell.num)) %>% 
  map(~dplyr::select(., i = cell.num, contains("tile.id.num"), pij)) %>% 
  map(~rename(., j = contains("tile.id.num"))) %>% 
  map(as.data.table)


### spm versions
P.star.matrices.spm <- P.long.mismatch.complete %>%
  map(~arrange(., cell.num)) %>% 
  map(~dplyr::select(., i = cell.num, contains("tile.id.num"), x = pij)) %>% 
  map(~rename(., j = contains("tile.id.num"))) %>% 
  map(~sparseMatrix(i = .$i, j = .$j, x = .$x))


### prior vector versions
a.tile.helper <- area$area.df %>% 
  dplyr::select(contains("tile.id.num"), a)

a.tile.vec <- a.tile.helper %>% 
  deframe()

a.tile.dt <- a.tile.helper %>% 
  dplyr::select(j = contains("supertile.id.num"), u = a) %>% 
  as.data.table()

### C vector, adding antennas that have 0 phones to complete the vector, arranging it according to the antenna.ID and saving as vector
c.vec <- gen.model.objects$P.long.complete.df %>% 
  map(~distinct(., cell.num, phones.sum)) %>% 
  map2(., cellplans.list, ~right_join(.x, .y$cellplan.combined.df, by = "cell.num")) %>% 
  map(~mutate(., phones.sum = case_when(is.na(phones.sum) ~ 0,
                                TRUE ~ phones.sum))) %>% 
  map(~arrange(., cell.num)) %>% 
  rep(., length(mismatch.versions) / length(.))

# define c-vector in datatable version
c.vec.dt <- map(c.vec, ~data.table(i = .x$cell.num,
                                   c = .x$phones.sum))

n.iter.MLE = 200
```



### Voronoi estimators

```{r VOR.tower, warning=FALSE, echo=FALSE, out.width="50%"}
# Voronoi estimation with tower locations as seeds
VOR.tower.names.est <- paste0("u.VOR.tower_", names(tower.dist.list))
VOR.input.list <- list(cellplan.combined, signal.strength.comb.dt, C.vec.df)

VOR.tower <- pmap(VOR.input.list, ~VOR_est(area = area, 
                                           cellplan.combined = ..1, 
                                           signal.strength.comb.dt = ..2, 
                                           C.vec.df = ..3, 
                                           seed = "tower"))
VOR.tower.est <- VOR.tower %>% 
  map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
  map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.tower = u.VOR)) %>% 
  map_at(-c(1), ~dplyr::select(., u.VOR.tower = u.VOR)) %>% 
  map2(., VOR.tower.names.est, ~rename_with(.x, 
                                            stringr::str_replace, 
                                            pattern = "u.VOR.tower", replacement = .y, 
                                            .cols = starts_with("u.VOR.tower"))) %>% 
  bind_cols()

VOR.tower$dense$Voronoi.regions.plot +
  labs(subtitle = "dense", title = "seed = tower")
VOR.tower$sparse$Voronoi.regions.plot +
  labs(subtitle = "sparse", title = "seed = tower")
```

```{r VOR.offset, warning=FALSE, echo=FALSE, out.width="50%"}
# Voronoi estimation with cell locations + offset as seeds
VOR.offset.names.est <- paste0("u.VOR.offset_", names(tower.dist.list))
VOR.offset <- pmap(VOR.input.list, ~VOR_est(area = area, 
                                            cellplan.combined = ..1, 
                                            signal.strength.comb.dt = ..2, 
                                            C.vec.df = ..3, 
                                            seed = "cell.offset",
                                            offset = 10)) 
VOR.offset.est <- VOR.offset %>% 
  map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
  map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.offset = u.VOR)) %>% 
  map_at(-c(1), ~dplyr::select(., u.VOR.offset = u.VOR)) %>% 
  map2(., VOR.offset.names.est, ~rename_with(.x, 
                                            stringr::str_replace, 
                                            pattern = "u.VOR.offset", replacement = .y, 
                                            .cols = starts_with("u.VOR.offset"))) %>% 
  bind_cols()

VOR.offset$dense$Voronoi.regions.plot +
  labs(subtitle = "dense", title = "seed = offset")
VOR.offset$sparse$Voronoi.regions.plot +
  labs(subtitle = "sparse", title = "seed = offset")
```

```{r VOR.barycenter, warning=FALSE, echo=FALSE, out.width="50%"}
# Voronoi estimation with cell barycenter locations as seeds
VOR.barycenter.names.est <- paste0("u.VOR.barycenter_", names(tower.dist.list))
VOR.barycenter <- pmap(VOR.input.list, ~VOR_est(area = area, 
                                                cellplan.combined = ..1, 
                                                signal.strength.comb.dt = ..2, 
                                                C.vec.df = ..3, 
                                                seed = "cell.barycenter")) 
VOR.barycenter.est <- VOR.barycenter %>% 
  map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
  map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.barycenter = u.VOR)) %>% 
  map_at(-c(1), ~dplyr::select(., u.VOR.barycenter = u.VOR)) %>% 
  map2(., VOR.barycenter.names.est, ~rename_with(.x, 
                                            stringr::str_replace, 
                                            pattern = "u.VOR.barycenter", replacement = .y, 
                                            .cols = starts_with("u.VOR.barycenter"))) %>% 
  bind_cols()

VOR.barycenter$dense$Voronoi.regions.plot +
  labs(subtitle = "dense", title = "seed = barycenter")
VOR.barycenter$sparse$Voronoi.regions.plot +
  labs(subtitle = "sparse", title = "seed = barycenter")
```

### MLE/EM estimator

```{r MLE-estimator}
MLE.names.est <- paste0("u.MLE_", mismatch.versions)

MLE.input.list <- list(c.vec.dt, P.star.matrices.dt, a.tile.dt)

MLE.est <- pmap(MLE.input.list,
                  ~EM_est(c.vec.dt = ..1, 
                          P.dt = ..2, 
                          a.vec.dt = ..3, 
                          selected.range = c(1, 2, 5, 10, 50, 100, 200),
                          n.iter = n.iter.MLE,
                          message = F, 
                          ldt = 10^-04)) %>% 
  map2(., MLE.names.est, ~rename_with(.x, 
                                      stringr::str_replace, 
                                      pattern = "u", replacement = .y, 
                                      .cols = starts_with("u"))) %>% 
  list(., 
       as.list(paste0("prior.", MLE.names.est)), 
       paste0("supertile.id.num_", mismatch.versions)) %>% 
  
  pmap(., ~rename(..1, !!..3 := j, !!..2 := i.u)) %>% 
  list(., 
       supertile.joiner, 
       paste0("supertile.id.num_", mismatch.versions)) %>% 
  pmap(., ~right_join(..1, ..2, by = ..3)) %>%
  map(~group_by(., across(contains("supertile.id.num")))) %>% 
  map(~mutate(., across(starts_with("u.MLE"), ~ . / n()))) %>%
  map(ungroup) %>%
  map(~dplyr::select(., tile.id.num, starts_with("u.MLE"))) %>% 
  map(~arrange(., tile.id.num)) %>% 
  map(~dplyr::select(., -contains("tile.id"))) %>%
  bind_cols() %>%
  mutate(., across(starts_with("u.MLE"), ~if_else(is.na(.), 0, .)))
```

### DF estimator

```{r DF-estimator}
DF.names.est <- paste0("u.DF_", mismatch.versions)

DF.raw.input.list <- list(c.vec.dt, P.star.matrices.spm, a.tile.vec)
## DF
  # calculate raw DF estimates with supertiles
DF.raw.est <- pmap(DF.raw.input.list, ~DF_est(c.vec.dt = ..1,
                                              P.star.spm = ..2,
                                              a.supertile.vec = ..3))

names.supertile.vec <- a.tile.vec %>% 
  map(~as.numeric(names(.)))

# adjust raw DF estimate (clip)
DF.raw.est.dt <- names.supertile.vec %>% 
  map2(., DF.raw.est, ~data.table(j = .x, u = .y)) %>% 
  map(~.[, u := fifelse(u < 1, 1, u)]) # clip lower values than 1 to 1

DF.input.list <- list(c.vec.dt, P.star.matrices.dt, DF.raw.est.dt)

## Renormalizing with EM and bringing estimate on regular tile.id level
DF.est <- pmap(DF.input.list, ~EM_est(c.vec.dt = ..1, 
                                          P.dt = ..2, 
                                          a.vec.dt = ..3, 
                                          selected.range = c(1, 2, 5, 10, 50, 100, 200),
                                          n.iter = n.iter.MLE,
                                          message = F, 
                                          ldt = 10^-04)) %>% 
  map2(., DF.names.est, ~rename_with(.x, 
                                     stringr::str_replace, 
                                     pattern = "u", replacement = .y, 
                                     .cols = starts_with("u"))) %>% 
  list(., 
       as.list(paste0("prior.", DF.names.est)), 
       paste0("supertile.id.num_", mismatch.versions)) %>% 
  
  pmap(., ~rename(..1, !!..3 := j, !!..2 := i.u)) %>% 
  list(., 
       supertile.joiner, 
       paste0("supertile.id.num_", mismatch.versions)) %>% 
  pmap(., ~right_join(..1, ..2, by = ..3)) %>%
  map(~group_by(., across(contains("supertile.id.num")))) %>% 
  map(~mutate(., across(starts_with("u.DF"), ~ . / n()))) %>%
  map(ungroup) %>%
  map(~dplyr::select(., tile.id.num, starts_with("u.DF"))) %>% 
  map(~arrange(., tile.id.num)) %>% 
  map(~dplyr::select(., -contains("tile.id"))) %>%
  bind_cols() %>% 
  mutate(across(starts_with("u.DF"), ~if_else(is.na(.), 0, .)))
```

```{r estimation-combine}
### Evaluation
final.estimates.sf <- area$area.sf %>% 
  left_join(VOR.tower.est, by = "tile.id.chr") %>%
  left_join(VOR.offset.est, by = "tile.id.chr") %>%
  left_join(VOR.barycenter.est, by = "tile.id.chr") %>%
  mutate(u.flat = mean(pop)) %>% 
  arrange(tile.id.num) %>%
  bind_cols(MLE.est) %>% 
  bind_cols(DF.est)

saveRDS(final.estimates.sf, "workflow_objects/final.estimates.sf.rds")


# non-sf version
final.estimates.df <- final.estimates.sf %>% 
  st_drop_geometry()

# vector with names of the relevant estimates
names.final.estimates <- final.estimates.sf %>% 
  dplyr::select(pop, starts_with("u.")) %>% # all estimates
  # dplyr::select(pop, matches(as.character(n.iter.MLE)), matches("VOR")) %>% # only "final" ones for mapping
  st_drop_geometry() %>% 
  names()
```

## Evaluation

### Spatial Density

```{r estimation-maps}
# Define break points for discretized spatial density plots
breaks <- c(0, 2, 5, 10, 20, 50, 100, 200, 350, Inf)
maps.input <- final.estimates.sf %>% 
  dplyr::select(tile.id, pop, X.centroid, Y.centroid, all_of(names.final.estimates)) %>% 
  mutate(across(c(pop, starts_with("u.")), ~cut(., breaks = breaks, dig.lab = 7, right = F)))

# Build maps and print
(maps.estimation.density <- names.final.estimates %>%
    map(~map_density(data = maps.input, var = .x, label = .x)) %>%
    set_names(names.final.estimates))

# saving maps
# walk2(maps.estimation.density, names(maps.estimation.density),
#       ~ggsave(filename = paste0(.y, ".png"), plot = .x,
#               path = paste0(getwd(), "/Poster/"), device = "png"))


```

### KWD all estimators

```{r kwd-computation}
# develop dataframe with GTP, all final estimates and tile centroids
kwd.helper.est <- final.estimates.sf %>% 
  dplyr::select(tile.id.num, pop, all_of(names.final.estimates)) %>%
  # dplyr::select(-c(elevation, type), -matches("prior")) %>%
  st_centroid() %>% 
  mutate(lon = unlist(map(.$geometry, 1)),
         lat = unlist(map(.$geometry, 2))) %>% 
  st_drop_geometry()

# Coordinates object
coordinates <- kwd.helper.est %>% 
  dplyr::select(lon, lat) %>% 
  as.matrix()

# Weights object
weights <- kwd.helper.est %>% 
  # dplyr::select(pop, matches("200")) %>%
  dplyr::select(pop, starts_with("u.")) %>%
  as.matrix()


# Approximation parameter (the higher the more accurate)
L = 2

# Run KWD
kwd.final <- compareOneToMany(coordinates, weights, L = L, recode = TRUE)
paste("KWD runtime ( L =", L, "):", round(kwd.final$runtime / 60, 0), "min for", 
      ncol(weights) - 1, "estimates and", 
      length(final.estimates.df$tile.id), "tiles")

# Define names for estimators
names.weights <- colnames(weights)[-1]

order.mismatch <- str_replace(mismatch.versions, paste0(names(tower.dist.list), "."), "")


# Develop data frame on the estimtor level with respective KWD values
kwd.eval <- tibble(estimator = names.weights,
                   kwd = kwd.final$distance * 1) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 2.68)) %>%  # for L=3 within 1 percent 
  mutate(network.kind = str_extract(estimator, pattern = paste0(names(tower.dist.list), collapse = "|"))) %>% 
  mutate(iteration = str_extract(estimator, "[[:digit:]]+$")) %>% 
  mutate(version = case_when(str_detect(estimator, "true") ~ "true",
                             TRUE ~ str_extract(estimator, 
                                                pattern = paste(c(order.mismatch, "flat"), collapse = "|")))) %>% 
  # kind = substr(estimator, 1, 11)) %>%
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(estimator.kind = str_extract(estimator, pattern = "MLE|DF|flat")) %>% 
  group_by(version, estimator.kind) %>% 
  mutate(final.iteration = case_when(iteration == max(iteration) ~ T,
                                     T ~ F)) %>% 
  mutate(min.KWD = case_when(kwd == min(kwd) ~ T,
                             T ~ F)) %>% 
  ungroup()  %>% 
  mutate(version.kind = case_when(str_detect(version, "no") ~ "Noise",
                                  str_detect(version, "quant") ~ "Quantization",
                                  str_detect(version, "true") ~ "True"))

saveRDS(kwd.eval, "workflow_objects/kwd.eval.rds")

```

### KWD for estimates with no model mismatch

```{r kwd_1}
case_when_estimator <- function(estimator, iteration) {
  case_when(
    str_detect(estimator, "u.VOR.tower") ~ "VOR.t",
    str_detect(estimator, "u.VOR.offset") ~ "VOR.o",
    str_detect(estimator, "u.VOR.barycenter") ~ "VOR.b",
    str_detect(estimator, "u.MLE") & iteration == 1 ~ "SB",
    str_detect(estimator, "u.MLE") ~ "MLE",
    str_detect(estimator, "u.DF") ~ "DF.MLE",
  )
}


(kwd.final.estimates.plot <- kwd.eval %>% 
    filter(str_detect(estimator, "VOR|true")) %>% 
    filter(final.iteration == T) %>% 
    mutate(estimator.name = case_when_estimator(estimator, iteration)) %>% 
    mutate(estimator.name.ordered = reorder(estimator.name, kwd)) %>%
    ggplot(aes(x = estimator.name.ordered, y = kwd, fill = estimator.name.ordered)) + 
    geom_bar(stat = "identity", position = position_dodge(width = 0.9)) + 
    geom_errorbar(aes(ymin = kwd.lower.bound, ymax = kwd), position = position_dodge(width = 0.9), width = 0.25) +
    geom_text(aes(label = round(kwd, 2)), 
              position = position_dodge(1), hjust = -0.1, color = "Black", size = 3) +
    scale_fill_ptol() +
    coord_flip() +
    facet_wrap(vars(network.kind), ncol = 1) +
    labs(title = "KWD for (converged) estimates with no model mismatch",
         x = "", y = "KWD", 
         alpha = "Iteration", fill = "") + 
    theme(legend.position = "none"))
```

### KWD after `r n.iter.MLE` iterations

```{r kwd-noise}
order.noise.levels <- c(str_subset(order.mismatch, "true"), 
                        str_subset(order.mismatch, "true|quant", negate = T)) %>%
  str_replace(., "no_true", "true")  %>% 
  unique(.)


(kwd.noise.plot <- kwd.eval %>% 
    filter(iteration == n.iter.MLE) %>% 
    filter(version.kind %in% c("Noise", "True")) %>% 
    mutate(version.ordered = factor(version, levels = order.noise.levels)) %>%
    ggplot(aes(x = version.ordered, y = kwd, color = estimator.kind, group = estimator.kind)) +
    geom_line(size = 1) +
    geom_point() +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version), 
                alpha = 0.2, color = "transparent") +
    geom_text_repel(aes(label = round(kwd, 2)), size = 3, show.legend  = F) +
    scale_color_ptol() +
    facet_wrap(vars(network.kind), scales = "free_x") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    labs(x = "Version",
         y = "KWD", color = "Estimator",
         title = "KWD final estimates random noise model mismatch"))
```

```{r kwd-quant}
order.quant.levels <- c(str_subset(order.mismatch, "true"),
                        rev(str_subset(order.mismatch, "no_|true", negate = T))) %>% 
  str_replace(., "no_true", "true")  %>% 
  unique(.)

(kwd.quant.plot <- kwd.eval %>% 
    filter(iteration == n.iter.MLE) %>% 
    filter(version.kind %in% c("Quantization", "True")) %>% 
    mutate(version.ordered = factor(version, levels = order.quant.levels)) %>%
    ggplot(aes(x = version.ordered, y = kwd, color = estimator.kind, group = estimator.kind)) +
    geom_line(size = 1) +
    geom_point() +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version), 
                alpha = 0.2, color = "transparent") +
    geom_text_repel(aes(label = round(kwd, 2)), size = 3, show.legend  = F) +
    scale_color_ptol() +
    facet_wrap(vars(network.kind), scales = "free_x") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    labs(x = "Version",
         y = "KWD", color = "Estimator",
         title = "KWD final estimates Quantization model mismatch"))
```

### KWD convergence for numerical estimators

```{r kwd-convergence, warning=FALSE}
# log scale breaks for background grid
minor.breaks <- rep(1:9, 21) * (10^rep(-10:10, each = 9))

# develop line plot
(kwd.convergence.noise.plot <- kwd.eval %>% 
    filter(!estimator.kind == "flat") %>% 
    filter(version.kind == "Noise") %>% 
    mutate(version.ordered = factor(version, levels = order.noise.levels)) %>%
    ggplot(aes(x = iteration, y = kwd, color = version.ordered)) +
    geom_line() +
    geom_point(aes(size = min.KWD), show.legend = F) +
    facet_wrap(vars(network.kind, estimator.kind), nrow = 2) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version.ordered), 
                alpha = 0.2, color = "transparent") +
    scale_color_ptol() +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x)),
                  minor_breaks = minor.breaks) +
    annotation_logticks(sides = "b") +
    labs(color = "Random Noise",
         x = "Iteration",
         y = "KWD",
         title = "Random Noise: KWD convergence behavior per estimator",
         subtitle = "The bigger dot indicates the lowest KWD value in the series"))

(kwd.convergence.quant.plot <- kwd.eval %>% 
    filter(!estimator.kind == "flat") %>% 
    filter(version.kind == "Quantization") %>% 
    mutate(version.ordered = factor(version, levels = order.quant.levels)) %>%
    ggplot(aes(x = iteration, y = kwd, color = version.ordered)) +
    geom_line() +
    geom_point(aes(size = min.KWD), show.legend = F) +
    facet_wrap(vars(network.kind, estimator.kind), nrow = 2) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version.ordered), 
                alpha = 0.2, color = "transparent") +
    scale_color_ptol() +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x)),
                  minor_breaks = minor.breaks) +
    annotation_logticks(sides = "b") +
    labs(color = "Quantization",
         x = "Iteration",
         y = "KWD",
         title = "Quantization: KWD convergence behavior per estimator",
         subtitle = "The bigger dot indicates the lowest KWD value in the series"))

```

```{r}
sessionInfo()
```
