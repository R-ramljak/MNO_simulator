---
title: "MNO spatial density estimates (rough draft!!!)"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: show
    code_download: true
    theme: sandstone
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: yes
---

# Introduction

Data generated by the cellular network of a mobile network operator (MNO) represent a rich potential source for estimating the spatial distribution of mobile phones at some given time and, from there, gain insight into the temporal variations of the spatial distribution of humans -- relevant for applications in, e.g., demography, tourism statistics and urban planning. The processing pipeline from raw MNO data to the final spatial density map requires modeling the (approximate) spatial footprint of individual radio cells -- a task called "cell geo-location".

Some recent work has shown that, with appropriate estimation methods based on stochastic models, the availability of more detailed cell footprint information allows to improve considerably the spatial accuracy of the final estimate compared with the simpler traditional methods relying on Voronoi tessellations. However, such results were obtained (i) under the assumption of perfect cell footprint knowledge and (ii) limited to a single scenario characterized by a dense multi-layer radio coverage pattern with high degree of cell overlapping.

In the present follow-up work we conduct an extensive sensitivity analysis of various estimators based on different cell geo-location methods. We investigate the sensitivity of estimation accuracy (i) to uncertainties in cell footprint modeling due to imperfect knowledge of the radio propagation environment and (ii) to various scenario parameters concerning the radio coverage pattern (e.g. density and degree of overlapping cells, multiple network layers). Owing to the spatial nature of the estimation problem, the Kantorovich-Wasserstein distance is used to measure the (dis)similarity between the estimated density and the true population distribution.

This notebook constitutes a working draft version of a future article concerning the spatial density estimation based on mobile network operator data (MNO). In the final version this notebook will accompany the article as a technical appendix. 


## Toyworld generation

The toyworld is created trough a semi-synthetic data. The general focus area is Munich and its near surroundings, the population values per tile are on the 100x100m level and originate from the German census. Finally, the radio network is fully synthetic and contains only directional cells. Cells are specified and modelled with the help of the `mobloc` package. The most important parameters are listed and visualized in the following:

```{r setup, message=FALSE}
# Data manipulation
library(tidyverse)
library(data.table) 

# Spatial operations
library(sf)
library(raster)
library(stars)

# Matrix operations
library(Matrix)

# MNO data handling and propagation model setup
# Credits to Prof. Martijn Tennekes https://github.com/mtennekes/mobloc
library(mobloc)

# Comparison of 2d histograms (Kantorovitch Wasserstein distance a.k.a. Earth Movers distance)
# Credits to Prof. Stefano Gualandi https://cran.r-project.org/web/packages/SpatialKWD/SpatialKWD.pdf
library(SpatialKWD)

# Output organisation and plotting support
library(ggthemes)
library(viridis)
library(ggrepel)
library(ggpointdensity)
library(scattermore)
library(grid)
library(gridExtra)
library(knitr)
library(DT)

# seed for reproducibility
set.seed(42)


# Loading Custom functions
source("pipeline functions.R")

```

### Specify the area and the mobile phone population

```{r population-data}
# data read in
munich.raw <- readRDS("Data/munich.rds")

# define raster object from focus area
munich.raster <- rasterFromXYZ(munich.raw, crs = st_crs(3035)$proj4string)

# define empty list object where all GTP objects will be stored
munich <- NULL

# define sf version of raster object
munich$area.sf <- munich.raster %>%
  st_as_stars() %>%
  st_as_sf() %>%
  mutate(centroid.geometry = st_centroid(.$geometry)) %>% 
  mutate(X.centroid = unlist(map(.$centroid.geometry, 1)),
         Y.centroid = unlist(map(.$centroid.geometry, 2))) %>% 
  dplyr::select(tile.id, pop, elevation, X.centroid, Y.centroid) %>%
  mutate(tile.id.chr = as.character(tile.id)) %>% 
  mutate(tile.id.fac = factor(tile.id.chr)) %>% 
  mutate(tile.id.num = as.numeric(tile.id.fac)) %>% 
  mutate(type = "NA") # only necessary if different tile types can be defined (urban, rural, etc...)

# regular dataframe version
munich$area.df <- munich$area.sf %>%
  st_drop_geometry()

# variable reduced dataframe version
munich$area.reduced.df <- munich$area.df %>% 
  dplyr::select(tile.id.chr, contains("centroid"))

# unionized version of focus area
munich$area.union <- munich$area.sf %>%
  st_union()

# bounding box coordinates of focus area
munich$area.bbox <- munich$area.union %>%
  st_bbox(crs = sf::st_crs(3035))

# specify raster object and tile id number
munich$area.raster <- munich.raster %>%
  raster(., layer = "tile.id")

# specify raster object and elevation value of each tile (here considered as constant)
munich$area.elevation <- munich.raster %>%
  raster(., layer = "elevation")

# number of tiles
munich$area.params[["tile.num"]] <- length(munich$area.df$tile.id)

# size of tiles
munich$area.params[["base.tile.size"]] <- as.numeric(sqrt(st_area(munich$area.sf[1,])))

# storing everything in area object
area <- munich

saveRDS(area, "workflow_objects/area.rds")
```

```{r gtp-map, fig.cap="Spatial population density of the ground truth population"}
# adjustable break points for map categories
breaks <- c(0, 2, 5, 10, 20, 50, 100, 200, 350, Inf)
# plot map and print
(d <- area$area.sf %>% 
  mutate(pop.cat = cut(pop, breaks = breaks, dig.lab = 7, right = F)) %>% 
  map_density(data = ., var = "pop.cat", label = "Phone density"))

ggsave("Poster/GTP.new.png", d, device = "png", bg = "transparent")
```

```{r pop-summary}
# summary descriptives of GTP
pop_summary_results(area$area.sf) %>% 
  dplyr::select(n.tiles = n.type, mean.pop, sd.pop, min.pop, max.pop, sum.pop)

```

```{r density-plot, fig.cap="Distribution of the ground truth population"}
# ECCDF and ECDF of GTP
(density_plots(area$area.df))
```

### Generate a radio network

#### Specify the first batch of network parameters

```{r, network-parameters-1, message=FALSE, warning=FALSE, fig.height=8, fig.width=10, fig.cap="Theoretical radio network parameters for each layer"}
# specify parameters of each cell
ME.cell.param.mobloc <- mobloc_param(W = 50, range = 8000, ple = 3.7, height = 10,
                                     midpoint = -85, steepness = 0.3, sig_d_th = 0.05)
# create dataframe for theoretical signal strength distribution
param.df <- tibble(cell.kind = c("ME"),
                   label = c("Meso"),
                   W = c(ME.cell.param.mobloc$W),
                   ple = c(ME.cell.param.mobloc$ple),
                   range = c(ME.cell.param.mobloc$range),
                   midpoint = c(ME.cell.param.mobloc$midpoint),
                   steepness = c(ME.cell.param.mobloc$steepness),
                   dominance.th = c(ME.cell.param.mobloc$sig_d_th))

# reduced data frame of theoretical signal strength distribution
param.df.reduced <- param.df %>% 
  dplyr::select(cell.kind, dominance.th)

# theoretical signal strength parameter plots
sig.pram.plots <- sig_param_plots(param.df = param.df, range.max = 15000, base_size = 11)

# print
(a <- ggpubr::as_ggplot(sig.pram.plots$final))
```

#### Densification

As mentioned above the central hypothesis for the Voronoi estimators is that any mobile phone connects with the closest cell in terms of distance. This translates into a high correlation between signal dominance and distance (IS THIS CORRECT??). We expect this assumption to break the more cells that are potentially available for a specific tile - high cell competition translates into higher overlap. The higher the overlap, the worse the Voronoi estimators will perform.

To test this assumption, we specify three kinds of networks that differ in their level of coverage density. The higher the density the higher the overlap between different cell footprints. To actually measure this overlap, robust indicators still need to be explored. The different networks are categorized as (1) dense, (2) middle and (3) sparse. The density level is solely controlled by the `tower.dist` parameter within the custom `create_cells()` function. This parameter controls the distance between every border point within the hexagonal base grid for creating the network. Each border point will translate to a tower, which means that the smaller the distance the more towers will be created and the bigger the distance lesser towers will be created.

Later on we will improve this experiment by also introducing different network layers with different cell parameters. This will enrich the experiment as here the competing cells for a specific tile entail different network characteristics potentially decreasing even more the correlation between distance and signal dominance.

```{r}
set.seed(20)

# specify the level of density for the different networks
tower.dist.list <- c(dense = 2000, sparse = 4100)

ME.cells.unparam <- map(tower.dist.list, ~create_cells(area.sf = area$area.sf,
                                                       tower.dist = .x, rotation.deg = 35,
                                                       jitter = 3, small = FALSE,
                                                       subscript = "ME", seed = 7))


# create the cellplan and validate it with the specified parameters
ME.cellplan.val <- map(ME.cells.unparam, ~create_cellplan(area.sf = area$area.sf,
                                                          area.bbox = area$area.bbox,
                                                          area.elevation = area$area.elevation,
                                                          cells.unparam = .x,
                                                          cell.param.mobloc = ME.cell.param.mobloc))

# compute signal strength and device to cell association
ME.signal.strength <- map(ME.cellplan.val, ~compute_sig_strength(cp = .x$cellplan.val,
                                                                 raster = area$area.raster,
                                                                 param = .x$cell.param.mobloc,
                                                                 elevation = area$area.elevation))
```

```{r, network-parameters-4}
cellplan.combined <- map(ME.cellplan.val, ~bind_rows(as_tibble(.x$cellplan.val))) %>% 
  map(~mutate(., cell.kind = substr(cell, 1, 2))) %>% 
  map(~mutate(., cell.chr = as.character(cell))) %>% 
  map(~mutate(., cell.fac = factor(cell.chr))) %>% 
  map(~mutate(., cell.num = as.numeric(cell.fac))) %>% 
  map(~left_join(., param.df.reduced, by = "cell.kind")) # join dominance threshold to use later in create_strength_llh()

# to join variable dominance.th later on
cellplan.combined.reduced <- cellplan.combined %>% 
  map(~dplyr::select(., cell.chr, dominance.th))


# create signal strength object of all cells
signal.strength.comb.dt <- map(ME.signal.strength, ~rbindlist(list(.x))) %>% 
  map(~mutate(., tile.id.chr = as.character(rid))) %>% 
  map(~mutate(., tile.id.fac = factor(tile.id.chr, levels = fct_unique(area$area.sf$tile.id.fac)))) %>% 
  map(~mutate(., tile.id.num = as.numeric(tile.id.fac))) %>% 
  map(~mutate(., cell.chr = as.character(cell))) %>% 
  map2(cellplan.combined, ~mutate(.x, cell.fac = factor(cell.chr, levels = fct_unique(.y$cell.fac)))) %>% 
  map(~mutate(., cell.num = as.numeric(cell.fac))) %>% 
  map(~left_join(., area$area.reduced.df, by = "tile.id.chr")) %>% 
  map(~as.data.table(.))


signal.strength.summary.helper <- signal.strength.comb.dt %>%
  map(~as_tibble(.)) %>%
  map(~mutate(., cell.kind = substr(cell.chr, 1, 2))) %>%
  map2(cellplan.combined.reduced, ~left_join(.x, .y, by = c("cell.chr"))) %>% 
  map(~filter(., !s < dominance.th)) # filter rows out that are below the set dominance threshold

signal.strength.summary <- signal.strength.summary.helper %>% 
  map(~group_by(., tile.id.chr)) %>%
  map(~mutate(., max.dBm = max(dBm),
              max.s = max(s),
              min.dist = min(dist),
              count = n())) %>%
  map(~ungroup(.))

# identify the cell-tile relations with maximum signal dominance and identify tiles that are not covered sufficiently
signal.dom <- signal.strength.summary %>% 
  map(~distinct(., tile.id.chr, max.s)) %>%
  map2(signal.strength.summary, ~left_join(.x, .y, by = c("tile.id.chr", "max.s" = "s"))) %>% 
  map(~dplyr::select(., tile.id.chr, max.s, cell.chr, cell.kind)) %>% 
  map(~full_join(., area$area.sf, by = "tile.id.chr")) %>% 
  map(~mutate(., missing = case_when(is.na(max.s) ~ 1,
                                     TRUE ~ 0)))

# how many tiles are not sufficiently covered (per network)
map(signal.dom, ~paste0("Number of tiles which do not reach the signal dominance threshold of: " , sum(.x$missing)))

```

```{r spatial-density-network-kind}
# Compare the network densities, spatial density plot
cells.helper <- ME.cellplan.val %>% 
  map_dfr(~bind_rows(.x$cellplan.val), .id = "network.kind") %>% 
  mutate(network.kind = factor(network.kind, levels = c("sparse", "dense"))) %>% 
  split(.$network.kind)

(network.spatial.density <- signal.dom %>% 
    map(~st_as_sf(.)) %>% 
    bind_rows(.id = "network.kind") %>% 
    mutate(network.kind = factor(network.kind, levels = c("sparse", "dense"))) %>% 
    ggplot() +
    geom_scattermore(aes(x = X.centroid, y = Y.centroid, color = max.s),
                     pointsize = 1.9, pixels = c(900, 900)) +
    scale_color_gradient(low = "white", high = "black", na.value = "red", 
                         limits = c(0, 1)) +
    geom_point(data = cells.helper$dense, aes(x, y), color = "#F8766D", alpha = 0.3) +
    geom_point(data = cells.helper$sparse, aes(x, y), color = "#00BFC4", alpha = 0.3) +
    coord_sf() +
    labs(x = "", y = "", color = "Signal strength",
         title = "") +
    theme_bw() +
    theme(legend.position = "bottom",
          text = element_text(size = 20),
          legend.key.size = unit(1, "cm"),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),
          rect = element_rect(fill = "transparent"),
          plot.background=element_rect(fill="transparent", colour=NA)) +
    facet_wrap(vars(network.kind), ncol = 2))

ggsave("Poster/network.density.png", network.spatial.density, device = "png", bg = "transparent")

```

```{r histogram-network-kind}
# Compare the network densities, histograms
(network.density.hist <- signal.strength.summary %>% 
  map(~distinct(., tile.id.chr, count)) %>% 
  bind_rows(.id = "network.kind") %>% 
  ggplot() +
  geom_histogram(aes(count, fill = network.kind, color = network.kind), 
                 position = "identity", alpha = 0.7, binwidth = 1) +
  labs(x = "Number of overlapping cells per tile", color = "Network kind", fill = "Network kind",
       title = "") +
   theme_bw()+
  theme(legend.position = "bottom",
        rect = element_rect(fill = "transparent"),
        text = element_text(size = 20),
        plot.background=element_rect(fill="transparent", colour=NA)))
  # facet_wrap(vars(network.kind), nrow = 3))
ggsave("Poster/network.density.hist.png", network.density.hist, device = "png", bg = "transparent",
       height = 3.5)
```

### Device-to-cell association

```{r dev-to-cell}
# specify the option of differing parameters for sig_d_th and max_overlapping_cells depending on the cell type in custom create_strength_llh function

# Workaround: securing that sig_d_th and max_overlapping_cells are the same for each layer
signal.strength.llh.param <- list(sig_d_th = 0.05,
                                  max_overlapping_cells = 100)

# define connection llh and classify tiles depending on coverage status
connection.llh <- map(signal.strength.comb.dt, ~create_strength_llh_custom(.x,
                                                                           signal.strength.llh.param, 
                                                                           smart.rounding.digits = 3, 
                                                                           area.df = area$area.df))
                      

# create c-vector
C.vec.df <- map(connection.llh, ~create_c_vector(.x$signal.strength.llh.combined))

# develop long format of P matrix which also contains certain cellplan parameters and "zero elements"
# develop different versions of id variables (tile and antennas) for easier joining
P.long.complete.df <- map2(connection.llh, C.vec.df, ~full_join(.x$signal.strength.llh.combined, .y, by = "cell")) %>% 
  # dplyr::select(tile.id, pop, elevation, cell, type, dist, pij, phones.sum) %>% 
  map(~dplyr::select(., tile.id.chr,, tile.id.fac, tile.id.num, pop, cell, type, dist, pij, phones.sum)) %>% 
  map(~mutate(., cell.chr = as.character(cell))) %>% 
  map2(cellplan.combined, ~mutate(.x, cell.fac = factor(cell.chr, levels = fct_unique(.y$cell.fac)))) %>% 
  map(~mutate(., cell.num = as.numeric(cell.fac)))

# Long format of P matrix with minimal variables and and unique rows
P.long.df <- P.long.complete.df %>% 
  map(~dplyr::select(., tile.id.chr, tile.id.fac, tile.id.num, cell.chr, cell.fac, cell.num, pij)) %>% 
  map(~distinct(.))

```

## Model mismatch techniques

### Random noise implementation

```{r noise-implementation}


# define the number of bits --> final number of levels are 2^n + 1
noise.expression <- c(no_03 = "runif(min = -3, max = 3",
                      # no_06 = "runif(min = -6, max = 6",
                      no_09 = "runif(min = -9, max = 9",
                      # no_12 = "runif(min = -12, max = 12",
                      no_15 = "runif(min = -15, max = 15",
                      # no_18 = "runif(min = -18, max = 18",
                      no_21 = "runif(min = -21, max = 21",
                      no_true = "runif(min = 0, max = 0")

noise.expression.wo.true <- names(noise.expression)[!names(noise.expression) == ("no_true")]
noise.expression.only.true <- names(noise.expression)[names(noise.expression) == ("no_true")]


# noise_mag <- function(x, expression, digits) {
#   
#   n <- length(x)
#   
#   expression.comp <- paste0(expression, ", n = ", n, ")")
#     
#   amount <- eval(parse(text = expression.comp))
#   
#   final <- x + round(amount, digits = digits)
#   
#   return(final)
#   
#   
# }
# 
# noise_mutate <- function(df, noise.expression, digits) {
#   
#   mutate(df, "dBm.noise.{noise.expression}" := noise_mag(x = dBm, expression = noise.expression, digits = digits))
# }
# 
# 
# P.long.noise.df.helper <- signal.strength.comb.dt %>% 
#   map(~mutate(., cell.kind = substr(cell, 1, 2))) %>% 
#   map(~left_join(., param.df, by = "cell.kind")) %>% 
#   map_dfr(~dplyr::rename(., sig_d_th = dominance.th), .id = "network.kind") %>% 
#   group_by(network.kind)
# 
# set.seed(222)
# 
# P.long.noise.complete.df <- noise.expression %>% 
#   map(~noise_mutate(df = P.long.noise.df.helper, noise.expression = .x, digits = 2)) %>% 
#   map(~ungroup(.)) %>% 
#   map2(., names(noise.expression), ~rename(.x, !!.y := starts_with("dBm.noise."))) %>% 
#   map_at(noise.expression.wo.true, ~dplyr::select(., starts_with("no_"))) %>%
#   bind_cols() %>% 
#   pivot_longer(cols = starts_with("no_"), names_to = "noise.level", values_to = "noise.mag") %>% 
#   split(list(.$network.kind, .$noise.level)) %>% 
#   map(~mutate(., s.mismatch.mag = db2s(noise.mag, midpoint, steepness)))
# 
# names.network.noise <- names(P.long.noise.complete.df)
# 
# P.long.noise.df <- P.long.noise.complete.df %>% 
#   map(~filter(., !s.mismatch.mag < 0.05)) %>% # define minimum threshold 
#   map(~mutate(., pij = con_llh_sens_custom(., "s.mismatch.mag", digits = 3))) %>% 
#   map(~mutate(., supertile.id = create_supertile_index(., elements = c("tile.id.chr", "cell.chr", "pij")))) %>% 
#   map(~mutate(., supertile.id.chr = as.numeric(supertile.id))) %>%
#   map(~mutate(., supertile.id.fac = factor(supertile.id.chr))) %>% 
#   map(~mutate(., supertile.id.num = as.numeric(supertile.id))) %>% 
#   map(~dplyr::select(., -supertile.id)) %>% 
#   map2(., paste0("supertile.id.chr_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.chr"))) %>% 
#   map2(., paste0("supertile.id.fac_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.fac"))) %>% 
#   map2(., paste0("supertile.id.num_", names.network.noise), ~rename(.x, !!.y := contains("supertile.id.num")))
#   
# saveRDS(P.long.noise.df, "workflow_objects/P.long.noise.df.rds")

P.long.noise.df <- readRDS("supercomputer/workflow_objects/P.long.noise.df.rds")
```

```{r}
# noise on the dBm scale
order.levels.noise <- c(noise.expression.only.true, noise.expression.wo.true)
# dense.names.noise <- names(P.long.noise.complete.df) %>% 
#   str_subset("dense") 

dense.names.noise <- names(P.long.noise.df) %>% 
  str_subset("dense") 

# (dBm.plot.ME <- P.long.noise.complete.df %>%
#   magrittr::extract(dense.names.noise) %>% 
#   map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, noise.mag, noise.level)) %>% 
#   filter(cell == ("ME.77.C.2")) %>% 
#   mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
#   left_join(area$area.sf, by = "tile.id.num") %>% 
#   st_as_sf() %>% 
#   ggplot() +
#   geom_sf(aes(fill = noise.mag), color = "transparent") +
#   scale_fill_viridis(na.value = "transparent") +
#   facet_wrap(vars(noise.level), ncol = 4) +
#   coord_sf() +
#   labs(title = "Meso noise on the dBm scale without minimum threshold", 
#        color = "dBm", fill = "dBm", x = "", y = "") +
#   theme(axis.text.x = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.x = element_blank(),
#         axis.ticks.y = element_blank(),
#         legend.position = "bottom"))


### HIER ETWAS ANDERES



# ggsave("workflow_objects/noise.dBm.plot.ME.png", dBm.plot.ME, device = "png")

# e <- dBm.plot.ME <- P.long.noise.complete.df %>%
#   magrittr::extract(dense.names.noise) %>% 
#   map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, s.mismatch.mag, noise.level)) %>% 
#   filter(cell == ("ME.77.C.2")) %>% 
#   mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
#   filter(noise.level == "no_true") %>% 
#   left_join(area$area.sf, by = "tile.id.num") %>% 
#   st_as_sf() 
# 
# (d <- e %>% 
#     ggplot() +
#     geom_sf(aes(fill = s.mismatch.mag), color = "transparent") +
#     scale_fill_continuous(na.value = "transparent", type = "viridis", limits = c(0, 1),
#                             labels = c("Bad", 0.25, 0.5, 0.75, "Excellent")) +
#     coord_sf() +
#     labs(title = "", 
#          color = "dBm", fill = "Signal strength\nin dominance", x = "", y = "") +
#     theme(axis.text.x = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks.x = element_blank(),
#           axis.ticks.y = element_blank(),
#           legend.key.size = unit(1, 'cm'), #change legend key size
#           legend.key.height = unit(1, 'cm'), #change legend key height
#           legend.key.width = unit(1, 'cm'), #change legend key width
#           legend.title = element_text(size=18), #change legend title font size
#           legend.text = element_text(size=14))) #change legend text font size))
#   
# ggsave("Indicator scheme/dom.png", d, device = "png", bg = "transparent")


# strength.dominance.plot <- ggplot(df) + 
#     geom_line(aes(x = dBm, y = sig.dom), size = 1.4) +
#   scale_x_continuous(limits = c(-100, -20)) +
#     labs(title = "", 
#          x = "Signal strength in dBm",
#          y = "Signal strength in dominance") +
#     guides(color = guide_legend(order = 1), 
#            linetype = guide_legend(order = 2)) +
#   theme_bw() +
#   theme(axis.line = element_line(colour = "black"),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         axis.text.x=element_blank(),
#         axis.ticks.x=element_blank(),
#         axis.text.y=element_blank(),
#         axis.ticks.y=element_blank(),
#         axis.title = element_text(size=25))
# ggsave("Indicator scheme/dom.vs.dbm.png", strength.dominance.plot, device = "png", bg = "transparent")
```

```{r}
# noise on the signal dominance scale



(dom.plot.ME.true <- P.long.noise.df %>% 
   magrittr::extract(dense.names.noise) %>% 
  map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, s.mismatch.mag, noise.level)) %>% 
  filter(cell == ("ME.77.C.2")) %>% 
   filter(noise.level == "no_true") %>% 
  mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
  left_join(area$area.sf, by = "tile.id.num") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = s.mismatch.mag), color = "transparent") +
  scale_fill_viridis(na.value = "transparent", limits = c(0, 1)) +
  facet_wrap(vars(noise.level), ncol = 5) +
  coord_sf() +
  labs(title = "", 
       color = "Signal Strength", fill = "Signal Strength", x = "", y = "") +
   theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        legend.key.size = unit(1, "cm"),
        text = element_text(size = 20),
        plot.background=element_rect(fill="transparent", colour=NA),
        legend.position = "bottom",
        rect = element_rect(fill = "transparent"),
        plot.margin=grid::unit(c(0,0,0,0), "mm")))

(dom.plot.ME.mismatch <- P.long.noise.df %>% 
   magrittr::extract(dense.names.noise) %>% 
  map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, s.mismatch.mag, noise.level)) %>% 
  filter(cell == ("ME.77.C.2")) %>% 
       filter(!noise.level == "no_true") %>% 
  mutate(noise.level = factor(noise.level, levels = order.levels.noise)) %>% 
  left_join(area$area.sf, by = "tile.id.num") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = s.mismatch.mag), color = "transparent") +
  scale_fill_viridis(na.value = "transparent", limits = c(0, 1)) +
  facet_wrap(vars(noise.level), ncol = 2) +
  coord_sf() +
  labs(title = "", 
       color = "Signal Strength", fill = "Signal Strength", x = "", y = "") +
    theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank(),
        text = element_text(size = 20),
        plot.background=element_rect(fill="transparent", colour=NA),
        legend.position = "none",
        rect = element_rect(fill = "transparent"),
        plot.margin=grid::unit(c(0,0,0,0), "mm")))

ggsave("Poster/noise.dom.plot.ME.true.png", dom.plot.ME.true, device = "png", bg = "transparent")
ggsave("Poster/noise.dom.plot.ME.mismatch.png", dom.plot.ME.mismatch, device = "png", bg = "transparent")
```

### Quantization

```{r}
# define the number of bits --> final number of levels are 2^n + 1

quant.levels <- c(# quant_00 = 0,
                  quant_01 = 1,
                  # quant_02 = 2,
                  # quant_03 = 3,
                  # quant_04 = 4,
                  # quant_05 = 5,
                  # quant_10 = 10,
                  quant_true = 0) # last version is just a placeholder, the "0" is meaningless

quant.levels.wo.true <- names(quant.levels)[!names(quant.levels) == ("quant_true")]
quant.levels.only.true <- names(quant.levels)[names(quant.levels) == ("quant_true")]


# 
quant_mutate <- function(df, n) {
  mutate(df, "s.quant.{n}" := quantize_mag(x = s, n = n))
}


P.long.quant.df.helper <- signal.strength.comb.dt %>%
  map(~mutate(., cell.kind = substr(cell, 1, 2))) %>%
  map(~left_join(., param.df, by = "cell.kind")) %>%
  map_dfr(~dplyr::rename(., sig_d_th = dominance.th), .id = "network.kind") %>%
  group_by(network.kind, cell.kind)

P.long.quant.complete.df <- quant.levels %>%
  map(~quant_mutate(df = P.long.quant.df.helper, n = .x)) %>%
  map(ungroup) %>%
  map_at(quant.levels.only.true, ~mutate(., s.quant.true = s)) %>%
  map_at(quant.levels.only.true, ~dplyr::select(., -s.quant.0)) %>%
  map2(., names(quant.levels), ~rename(.x, !!.y := starts_with("s.quant."))) %>%
  map_at(quant.levels.wo.true, ~dplyr::select(., starts_with("quant_"))) %>%
  bind_cols() %>%
  pivot_longer(cols = starts_with("quant_"), names_to = "quant.level", values_to = "quant.mag") %>%
  split(list(.$network.kind, .$quant.level))

names.network.quant <- names(P.long.quant.complete.df)

P.long.quant.df <- P.long.quant.complete.df %>%
  # map_at(c(1, 2), ~mutate(., quant.mag = 
  #                           case_when(quant.mag < 0.95 | quant.mag < 0.95 
  #                                     ~ round(quant.mag + runif(n(), min = -0.05, max = 0.05), 2),
  #                                     TRUE ~ quant.mag))) %>%
  map(~filter(., !quant.mag < 0.05)) %>% # define minimum threshold
  map(~mutate(., pij = con_llh_sens_custom(., "quant.mag", digits = 3))) %>%
  # map(~mutate(., supertile.id = create_supertile_index(., elements = c("tile.id.chr", "cell.chr", "pij")))) %>%
  # map(~mutate(., supertile.id.chr = as.numeric(supertile.id))) %>%
  # map(~mutate(., supertile.id.fac = factor(supertile.id.chr))) %>%
  # map(~mutate(., supertile.id.num = as.numeric(supertile.id))) %>%
  map(~mutate(., supertile.id.chr = tile.id.chr)) %>%
  map(~mutate(., supertile.id.fac = tile.id.fac)) %>%
  map(~mutate(., supertile.id.num = tile.id.num)) %>%
  # map(~dplyr::select(., -supertile.id)) %>%
  map2(., paste0("supertile.id.chr_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.chr"))) %>%
  map2(., paste0("supertile.id.fac_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.fac"))) %>%
  map2(., paste0("supertile.id.num_", names.network.quant), ~rename(.x, !!.y := contains("supertile.id.num")))

# saveRDS(P.long.quant.df, "workflow_objects/P.long.quant.df.rds")

# P.long.quant.df <- readRDS("supercomputer/workflow_objects/P.long.quant.df.rds")

```

```{r}
# quantization on the dominance scale without threshold
order.levels.quant <- c(quant.levels.only.true, rev(quant.levels.wo.true))
# dense.names.quant <- names(P.long.quant.complete.df) %>% 
#   str_subset("dense") 

dense.names.quant <- names(P.long.quant.df) %>%
  str_subset("dense")

# (dom.plot.ME <- P.long.quant.complete.df %>% 
#     magrittr::extract(dense.names.quant) %>% 
#     map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, quant.mag, quant.level)) %>% 
#     filter(cell == ("ME.77.C.2")) %>% 
#     mutate(quant.level = factor(quant.level, levels = order.levels.quant)) %>% 
#     left_join(area$area.sf, by = "tile.id.num") %>% 
#     st_as_sf() %>% 
#     ggplot() +
#     geom_sf(aes(fill = quant.mag), color = "transparent") +
#     scale_fill_viridis(na.value = "transparent") +
#     facet_wrap(vars(quant.level), ncol = 4) +
#     coord_sf() +
#     labs(title = "Meso quantization on the dominance scale without minimum threshold", 
#          color = "Signal\ndominance", fill = "Signal\ndominance", x = "", y = "") +
#     theme(axis.text.x = element_blank(),
#           axis.text.y = element_blank(),
#           axis.ticks.x = element_blank(),
#           axis.ticks.y = element_blank(),
#           legend.position = "bottom"))
# ggsave("workflow_objects/quant.dom.plot.ME.wo.th.png", dom.plot.ME, device = "png")
```

```{r}
# quantization on the dominance scale with threshold

(dom.plot.ME.th <- P.long.quant.df %>% 
   magrittr::extract(dense.names.quant) %>% 
   map_dfr(~dplyr::select(., cell, cell.kind, tile.id.num, quant.mag, quant.level)) %>% 
   filter(cell == ("ME.77.C.2")) %>% 
   mutate(quant.level = factor(quant.level, levels = order.levels.quant)) %>% 
   left_join(area$area.sf, by = "tile.id.num") %>% 
   st_as_sf() %>% 
   ggplot() +
   geom_sf(aes(fill = quant.mag), color = "transparent") +
   scale_fill_viridis(na.value = "transparent") +
   facet_wrap(vars(quant.level), ncol = 5) +
   coord_sf() +
   labs(title = "Meso quantization on the dominance scale with minimum threshold", 
        color = "Signal\ndominance", fill = "Signal\ndominance", x = "", y = "") +
   theme(axis.text.x = element_blank(),
         axis.text.y = element_blank(),
         axis.ticks.x = element_blank(),
         axis.ticks.y = element_blank(),
         legend.position = "bottom"))
# ggsave("workflow_objects/quant.dom.plot.ME.w.th.png", dom.plot.ME.th, device = "png")
```

```{r}
cell.kind.unique <- n_distinct(param.df$cell.kind)
range.total <- rep(seq(10, 20000, by = 10), cell.kind.unique)
length.range.total <- rep(length(range.total) / cell.kind.unique, cell.kind.unique)

# use the helpers to construct plot dataframe and join with the input params
df <- tibble(cell.kind = factor(rep(param.df$cell.kind, length.range.total)),
             distance = range.total) %>% 
  left_join(param.df, by = "cell.kind") %>% 
  mutate(dBm = W2dBm(W)) %>% 
  mutate(distance.log10 = log10(distance)) %>% 
  mutate(dBm = distance2dB(distance, ple, W)) %>% 
  mutate(s = db2s(dBm, 
                  midpoint = midpoint, 
                  steepness = steepness))

### theoretical quantization vs true
new.df.theo.vars <- quant.levels %>% 
  map(~quant_mutate(df = df, n = .x)) %>% 
  map_at(quant.levels.only.true, ~mutate(., s.quant.true = s)) %>% 
  map_at(quant.levels.only.true, ~dplyr::select(., -s.quant.0)) %>% 
  map2(., names(quant.levels), ~rename(.x, !!.y := starts_with("s.quant."))) %>% 
  map_at(quant.levels.wo.true, ~dplyr::select(., starts_with("quant_"))) %>%
  bind_cols() %>% 
  pivot_longer(cols = starts_with("quant_"), names_to = "quant.level", values_to = "quant.mag") %>% 
  mutate(below.dominance.th = case_when(quant.mag >= 0.05 ~ "Above", 
                                        quant.mag < 0.05 ~ "Below"))  %>% 
  mutate(quant.level = factor(quant.level, levels = order.levels.quant)) 


(theo.quant.plot <- new.df.theo.vars %>% 
  # filter(quant.level == "quant_true") %>% 
  ggplot() +
  # geom_point(aes(x = s, y = quant.mag, color = quant.level, group = quant.level))
  geom_line(aes(x = s, y = quant.mag, 
                color = quant.level), 
            size = 1) +
  facet_wrap(vars(quant.level), ncol = 5) +
  labs(x = "True signal dominance", 
       y = "Quantized signal dominance",
       color = "Quant. Version") +
  theme(legend.position = "bottom"))
# ggsave("workflow_objects//theo.quant.plot.png", theo.quant.plot, device = "png")
```

## Estimation

```{r estimation-input-parameters}
## estimation



P.long.mismatch.complete <- c(P.long.noise.df)
  # magrittr::extract(c("sparse.quant_01"))
  # discard(names(.) %in% c("dense.quant_true", "sparse.quant_true"))
mismatch.versions <- names(P.long.mismatch.complete)


supertile.joiner <- P.long.mismatch.complete %>%
  map(., ~right_join(.x, area$area.df, by = "tile.id.num")) %>%
  map(~dplyr::select(., tile.id.num, contains("supertile.id.num"))) %>%
  map(distinct) %>%
  map(~arrange(., tile.id.num))


### supertile helper
P.star.supertile.helper <- P.long.mismatch.complete %>%
  map(~dplyr::select(., contains("supertile.id"), contains("cell"), pij)) %>%
  map(distinct) %>%
  map(~arrange(., cell.num))


### datatable versions
P.star.matrices.dt <- P.star.supertile.helper %>%
  map(~dplyr::select(., i = cell.num, contains("supertile.id.num"), pij)) %>%
  map(~rename(., j = contains("supertile.id.num"))) %>%
  map(as.data.table)


### spm versions
P.star.matrices.spm <- P.star.supertile.helper %>%
  map(~dplyr::select(., i = cell.num, contains("supertile.id.num"), x = pij)) %>%
  map(~rename(., j = contains("supertile.id.num"))) %>%
  map(~sparseMatrix(i = .$i, j = .$j, x = .$x))


### prior vector versions
a.tile.helper <- supertile.joiner %>%
  map2(list(area$area.df), ~left_join(.x, .y, by = "tile.id.num")) %>% 
  map(~dplyr::select(., matches("supertile.id.num|pop"))) %>%
  # map(~mutate(., a = 1)) %>%
  map(~group_by(., across(contains("supertile.id.num")))) %>%
  map(~summarise(., a = sum(pop))) %>% # uniform vector of number of normal tiles
  map(distinct) %>%
  #map(~mutate(., a = 1)) %>% 
  map(drop_na) # uncovered tiles

a.tile.vec <- a.tile.helper %>%
  map(deframe)

a.tile.dt <- a.tile.helper %>%
  map(~dplyr::select(., j = contains("supertile.id.num"), u = a)) %>%
  map(as.data.table)

### threshold versions (Change to dynamic within version later)
# fixed threshold per version
th.values.dt <- a.tile.dt %>%
  map(~mutate(., ldt.th = 10^-04 / u)) %>%
  map(~dplyr::select(., -u)) %>%
  map(as.data.table)


### C vector, adding antennas that have 0 phones to complete the vector, arranging it according to the antenna.ID and saving as vector
c.vec <- list(P.long.complete.df$sparse) %>%
  map(~distinct(., cell.num, phones.sum)) %>%
  map2(list(cellplan.combined$sparse), ~right_join(.x, .y, by = "cell.num")) %>%
  map(~mutate(., phones.sum = case_when(is.na(phones.sum) ~ 0,
                                TRUE ~ phones.sum))) %>%
  map(~arrange(., cell.num)) %>%
  rep(., length(mismatch.versions) / length(.))

# define c-vector in datatable version
c.vec.dt <- map(c.vec, ~data.table(i = .x$cell.num,
                                   c = .x$phones.sum))

n.iter.MLE = 200
```

### Voronoi estimators

```{r VOR.tower, warning=FALSE, echo=FALSE, out.width="50%"}
# # Voronoi estimation with tower locations as seeds
# VOR.tower.names.est <- paste0("u.VOR.tower_", names(tower.dist.list))
# VOR.input.list <- list(cellplan.combined, signal.strength.comb.dt, C.vec.df)
# 
# VOR.tower <- pmap(VOR.input.list, ~VOR_est(area = area, 
#                                            cellplan.combined = ..1, 
#                                            signal.strength.comb.dt = ..2, 
#                                            C.vec.df = ..3, 
#                                            seed = "tower"))
# VOR.tower.est <- VOR.tower %>% 
#   map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
#   map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.tower = u.VOR)) %>% 
#   map_at(-c(1), ~dplyr::select(., u.VOR.tower = u.VOR)) %>% 
#   map2(., VOR.tower.names.est, ~rename_with(.x, 
#                                             stringr::str_replace, 
#                                             pattern = "u.VOR.tower", replacement = .y, 
#                                             .cols = starts_with("u.VOR.tower"))) %>% 
#   bind_cols()
# 
# VOR.tower$dense$Voronoi.regions.plot +
#   labs(subtitle = "dense", title = "seed = tower")
# VOR.tower$sparse$Voronoi.regions.plot +
#   labs(subtitle = "sparse", title = "seed = tower")
```

```{r VOR.offset, warning=FALSE, echo=FALSE, out.width="50%"}
# # Voronoi estimation with cell locations + offset as seeds
# VOR.offset.names.est <- paste0("u.VOR.offset_", names(tower.dist.list))
# VOR.offset <- pmap(VOR.input.list, ~VOR_est(area = area, 
#                                             cellplan.combined = ..1, 
#                                             signal.strength.comb.dt = ..2, 
#                                             C.vec.df = ..3, 
#                                             seed = "cell.offset",
#                                             offset = 10)) 
# VOR.offset.est <- VOR.offset %>% 
#   map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
#   map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.offset = u.VOR)) %>% 
#   map_at(-c(1), ~dplyr::select(., u.VOR.offset = u.VOR)) %>% 
#   map2(., VOR.offset.names.est, ~rename_with(.x, 
#                                             stringr::str_replace, 
#                                             pattern = "u.VOR.offset", replacement = .y, 
#                                             .cols = starts_with("u.VOR.offset"))) %>% 
#   bind_cols()
# 
# VOR.offset$dense$Voronoi.regions.plot +
#   labs(subtitle = "dense", title = "seed = offset")
# VOR.offset$sparse$Voronoi.regions.plot +
#   labs(subtitle = "sparse", title = "seed = offset")
```

```{r VOR.barycenter, warning=FALSE, echo=FALSE, out.width="50%"}
# # Voronoi estimation with cell barycenter locations as seeds
# VOR.barycenter.names.est <- paste0("u.VOR.barycenter_", names(tower.dist.list))
# VOR.barycenter <- pmap(VOR.input.list, ~VOR_est(area = area, 
#                                                 cellplan.combined = ..1, 
#                                                 signal.strength.comb.dt = ..2, 
#                                                 C.vec.df = ..3, 
#                                                 seed = "cell.barycenter")) 
# VOR.barycenter.est <- VOR.barycenter %>% 
#   map(~mutate(.x$seed.voronoi.final, tile.id.chr = as.character(tile.id))) %>% 
#   map_at(c(1), ~dplyr::select(., tile.id.chr, u.VOR.barycenter = u.VOR)) %>% 
#   map_at(-c(1), ~dplyr::select(., u.VOR.barycenter = u.VOR)) %>% 
#   map2(., VOR.barycenter.names.est, ~rename_with(.x, 
#                                             stringr::str_replace, 
#                                             pattern = "u.VOR.barycenter", replacement = .y, 
#                                             .cols = starts_with("u.VOR.barycenter"))) %>% 
#   bind_cols()
# 
# VOR.barycenter$dense$Voronoi.regions.plot +
#   labs(subtitle = "dense", title = "seed = barycenter")
# VOR.barycenter$sparse$Voronoi.regions.plot +
#   labs(subtitle = "sparse", title = "seed = barycenter")
```

### MLE/EM estimator

```{r MLE-estimator}
MLE.names.est <- paste0("u.MLE_", mismatch.versions) %>% 
  str_subset("quant_01")

MLE.input.list <- list(c.vec.dt, P.star.matrices.dt, a.tile.dt)


MLE.est <- pmap(MLE.input.list,
                  ~EM_est(c.vec.dt = ..1,
                          P.dt = ..2,
                          a.vec.dt = ..3,
                          selected.range = c(1, 2, 5, 10, 50, 100, 200),
                          n.iter = 200,
                          message = T,
                          ldt.dt = 0)) %>%
  map2(., MLE.names.est, ~rename_with(.x,
                                      stringr::str_replace,
                                      pattern = "u", replacement = .y,
                                      .cols = starts_with("u"))) %>%
  list(.,
       as.list(paste0("prior.", MLE.names.est)),
       paste0("supertile.id.num_", mismatch.versions)) %>%

  pmap(., ~rename(..1, !!..3 := j, !!..2 := i.u)) %>%
  list(.,
       supertile.joiner,
       paste0("supertile.id.num_", mismatch.versions)) %>%
  pmap(., ~right_join(..1, ..2, by = ..3)) %>%
  map(~group_by(., across(contains("supertile.id.num")))) %>%
  map(~mutate(., across(starts_with("u.MLE"), ~ . / n()))) %>%
  map(ungroup) %>%
  map(~dplyr::select(., tile.id.num, starts_with("u.MLE"))) %>%
  map(~arrange(., tile.id.num)) %>%
  map(~dplyr::select(., -contains("tile.id"))) %>%
  bind_cols() %>%
  mutate(., across(starts_with("u.MLE"), ~if_else(is.na(.), 0, .)))
```

### DF estimator

```{r DF-estimator}
# DF.names.est <- paste0("u.DF_", mismatch.versions)
# 
# DF.raw.input.list <- list(c.vec.dt, P.star.matrices.spm, a.tile.vec)
# ## DF
#   # calculate raw DF estimates with supertiles
# DF.raw.est <- pmap(DF.raw.input.list, ~DF_est(c.vec.dt = ..1,
#                                               P.star.spm = ..2,
#                                               a.supertile.vec = ..3))
# 
# names.supertile.vec <- a.tile.vec %>%
#   map(~as.numeric(names(.)))
# 
# # adjust raw DF estimate (clip)
# DF.raw.est.dt <- names.supertile.vec %>%
#   map2(., DF.raw.est, ~data.table(j = .x, u = .y)) %>%
#   map(~.[, u := fifelse(u < 1, 1, u)]) # clip lower values than 1 to 1
# 
# DF.input.list <- list(c.vec.dt, P.star.matrices.dt, DF.raw.est.dt, th.values.dt)
# 
# ## Renormalizing with EM and bringing estimate on regular tile.id level
# DF.est <- pmap(DF.input.list, ~EM_est(c.vec.dt = ..1,
#                                           P.dt = ..2,
#                                           a.vec.dt = ..3,
#                                           selected.range = c(1, 2, 5, 10, 50, 100, 200),
#                                           n.iter = n.iter.MLE,
#                                           message = F,
#                                           ldt.dt = ..4)) %>%
#   map2(., DF.names.est, ~rename_with(.x,
#                                      stringr::str_replace,
#                                      pattern = "u", replacement = .y,
#                                      .cols = starts_with("u"))) %>%
#   list(.,
#        as.list(paste0("prior.", DF.names.est)),
#        paste0("supertile.id.num_", mismatch.versions)) %>%
# 
#   pmap(., ~rename(..1, !!..3 := j, !!..2 := i.u)) %>%
#   list(.,
#        supertile.joiner,
#        paste0("supertile.id.num_", mismatch.versions)) %>%
#   pmap(., ~right_join(..1, ..2, by = ..3)) %>%
#   map(~group_by(., across(contains("supertile.id.num")))) %>%
#   map(~mutate(., across(starts_with("u.DF"), ~ . / n()))) %>%
#   map(ungroup) %>%
#   map(~dplyr::select(., tile.id.num, starts_with("u.DF"))) %>%
#   map(~arrange(., tile.id.num)) %>%
#   map(~dplyr::select(., -contains("tile.id"))) %>%
#   bind_cols() %>%
#   mutate(across(starts_with("u.DF"), ~if_else(is.na(.), 0, .)))
```

```{r estimation-combine}
### Evaluation
final.estimates.sf <- area$area.sf %>%
  # left_join(VOR.tower.est, by = "tile.id.chr") %>%
  # left_join(VOR.offset.est, by = "tile.id.chr") %>%
  # left_join(VOR.barycenter.est, by = "tile.id.chr") %>%
  # mutate(u.flat = mean(pop)) %>%
  arrange(tile.id.num) %>%
  bind_cols(MLE.est)
  # filter(X.centroid > 4430050 & X.centroid < 4445950,
  #        Y.centroid > 2775050 & Y.centroid < 2785950) %>% 
  # mutate_at(vars(matches("quant")), ~case_when(. > ((sum(pop) - sum(.)) / n()) + 1  
  #                                              ~. + ((sum(pop) - sum(.)) / n()),
                                               # TRUE ~ .))
  # bind_cols(DF.est)

# saveRDS(final.estimates.sf, "workflow_objects/final.estimates.sf.rds")

final.estimates.sf <- readRDS("supercomputer/workflow_objects/final.estimates.sf.rds")


# non-sf version
final.estimates.df <- final.estimates.sf %>%
  st_drop_geometry()

# vector with names of the relevant estimates
names.final.estimates <- final.estimates.sf %>%
  dplyr::select(pop, matches("no|VOR")) %>% # all estimates
  dplyr::select(pop, matches("200|VOR")) %>% # all estimates
  # dplyr::select(pop, matches(as.character(n.iter.MLE)), matches("VOR")) %>% # only "final" ones for mapping
  st_drop_geometry() %>%
  names()

# e <- final.estimates.sf %>% 
#   st_union()
# 
# area$area.union %>% 
#   ggplot() +
#   geom_sf() +
#   geom_sf(data = e)
# 
# d <- supertile.joiner$sparse.quant_01  %>% 
#   right_join(final.estimates.df, by = "tile.id.num") %>% 
#   group_by(supertile.id.num_sparse.quant_01) %>% 
#   summarise(e = n())
```

## Evaluation

### Spatial Density

```{r estimation-maps}
# Define break points for discretized spatial density plots
breaks <- c(0, 2, 5, 10, 20, 50, 100, 200, 350, Inf)
maps.input <- final.estimates.sf %>%
  dplyr::select(tile.id, pop, X.centroid, Y.centroid, all_of(names.final.estimates)) %>%
  mutate(across(c(pop, starts_with("u.")), ~cut(., breaks = breaks, dig.lab = 7, right = F)))

# Build maps and print
maps.estimation.density <- names.final.estimates %>%
    map(~map_density(data = maps.input, var = .x, label = .x)) %>%
    set_names(names.final.estimates)

# saving maps
walk2(maps.estimation.density, names(maps.estimation.density),
      ~ggsave(filename = paste0(.y, ".png"), plot = .x,
              path = paste0(getwd(), "/Poster/Maps/"), device = "png"))


```

### KWD all estimators

```{r kwd-computation}
# develop dataframe with GTP, all final estimates and tile centroids
kwd.helper.est <- final.estimates.sf %>%
  dplyr::select(tile.id.num, pop, all_of(names.final.estimates)) %>%
  # dplyr::select(-c(elevation, type), -matches("prior")) %>%
  st_centroid() %>%
  mutate(lon = unlist(map(.$geometry, 1)),
         lat = unlist(map(.$geometry, 2))) %>%
  st_drop_geometry()

# Coordinates object
coordinates <- kwd.helper.est %>%
  dplyr::select(lon, lat) %>%
  as.matrix()

# Weights object
weights <- kwd.helper.est %>%
  # dplyr::select(pop, matches("200")) %>%
  dplyr::select(pop, starts_with("u.")) %>%
  as.matrix()


# Approximation parameter (the higher the more accurate)
L = 2

# Run KWD
kwd.final <- compareOneToMany(coordinates, weights, L = L, recode = TRUE)
paste("KWD runtime (supercomputer) ( L =", L, "):", round(kwd.final$runtime / 60, 0), "min for",
      ncol(weights) - 1, "estimates and",
      length(final.estimates.df$tile.id), "tiles")

# Define names for estimators
names.weights <- colnames(weights)[-1]

order.mismatch <- str_replace(mismatch.versions, paste0(names(tower.dist.list), "."), "")
# 
# 
# Develop data frame on the estimtor level with respective KWD values
kwd.eval <- tibble(estimator = names.weights,
                   kwd = kwd.final$distance * 1) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 2.68)) %>%  # for L=3 within 1 percent
  mutate(network.kind = str_extract(estimator, pattern = paste0(names(tower.dist.list), collapse = "|"))) %>%
  mutate(iteration = str_extract(estimator, "[[:digit:]]+$")) %>%
  mutate(version = case_when(str_detect(estimator, "true") ~ "true",
                             TRUE ~ str_extract(estimator,
                                                pattern = paste(c(order.mismatch, "flat"), collapse = "|")))) %>%
  # kind = substr(estimator, 1, 11)) %>%
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>%
  mutate(estimator.kind = str_extract(estimator, pattern = "MLE|DF|flat")) %>%
  group_by(version, estimator.kind) %>%
  mutate(final.iteration = case_when(iteration == max(iteration) ~ T,
                                     T ~ F)) %>%
  mutate(min.KWD = case_when(kwd == min(kwd) ~ T,
                             T ~ F)) %>%
  ungroup()  %>%
  mutate(version.kind = case_when(str_detect(version, "no") ~ "Noise",
                                  str_detect(version, "quant") ~ "Quantization",
                                  str_detect(version, "true") ~ "True"))

# # saveRDS(kwd.eval, "workflow_objects/kwd.eval.rds")


kwd.eval <- readRDS("supercomputer/workflow_objects/kwd.eval.rds")
```

### KWD for estimates with no model mismatch

```{r kwd_1}
case_when_estimator <- function(estimator, iteration) {
  case_when(
    str_detect(estimator, "u.VOR.tower") ~ "VOR_t",
    str_detect(estimator, "u.VOR.offset") ~ "VOR_o",
    str_detect(estimator, "u.VOR.barycenter") ~ "VOR_b",
    str_detect(estimator, "u.MLE") & iteration == 1 ~ "SB",
    str_detect(estimator, "u.MLE") ~ "MLE",
    str_detect(estimator, "u.DF") ~ "DF",
  )
}


(kwd.final.estimates.plot <- kwd.eval %>% 
    filter(str_detect(estimator, "VOR|true")) %>% 
    filter(final.iteration == T) %>% 
    mutate(estimator.name = case_when_estimator(estimator, iteration)) %>% 
    mutate(estimator.name.ordered = reorder(estimator.name, kwd)) %>%
    ggplot(aes(x = estimator.name.ordered, y = kwd, fill = estimator.name.ordered)) + 
    geom_bar(stat = "identity", position = position_dodge(width = 0.9)) + 
    geom_errorbar(aes(ymin = kwd.lower.bound, ymax = kwd), position = position_dodge(width = 0.9), width = 0.25) +
    geom_text(aes(label = round(kwd, 2)), 
              position = position_dodge(1), hjust = -0.1, color = "Black", size = 3) +
    scale_fill_ptol() +
    coord_flip() +
    facet_wrap(vars(network.kind), ncol = 1) +
    labs(title = "KWD for (converged) estimates with no model mismatch",
         x = "", y = "KWD", 
         alpha = "Iteration", fill = "") + 
    theme(legend.position = "none"))
```

### KWD after `r n.iter.MLE` iterations

```{r kwd-noise}
order.noise.levels <- c(str_subset(order.mismatch, "true"), 
                        str_subset(order.mismatch, "true|quant", negate = T)) %>%
  str_replace(., "no_true", "true")  %>% 
  unique(.)

kwd.vor.helper <- kwd.eval %>% 
  mutate(estimator.name = case_when_estimator(estimator, iteration)) %>% 
  filter(str_detect(estimator.name, "VOR")) %>% 
  mutate(time = case_when(str_detect(estimator.name, "VOR") ~ 5,
                          TRUE ~ 1)) %>% 
  uncount(time) %>% 
  mutate(version = rep(order.noise.levels, 6))
  
  
(kwd.noise.plot <- kwd.eval %>% 
    # filter(str_detect(estimator, "VOR|true")) %>% 
    mutate(estimator.name = case_when_estimator(estimator, iteration)) %>% 
    filter(final.iteration == T) %>% 
    filter(!str_detect(estimator.name, "VOR")) %>% 
    filter(!estimator.name == "flat") %>%
    bind_rows(kwd.vor.helper) %>% 
    mutate(estimator.name.ordered = reorder(estimator.name, kwd)) %>% 
    filter(version.kind %in% c("Noise", "True") | is.na(version.kind)) %>% 
    mutate(version.ordered = factor(version, levels = order.noise.levels)) %>%
    ggplot(aes(x = version.ordered, y = kwd, color = estimator.name.ordered, group = estimator.name.ordered)) +
    geom_line(size = 1) +
    geom_point() +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version), 
                alpha = 0.2, color = "transparent") +
    geom_text_repel(aes(label = round(kwd, 2)), size = 7, show.legend  = F) +
    colorspace::scale_fill_discrete_qualitative(palette = "Harmonic") +
    facet_wrap(vars(network.kind), scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
          legend.position = "bottom",
          rect = element_rect(fill = "transparent"),
          text = element_text(size = 20),
        plot.background=element_rect(fill="transparent", colour=NA),
          plot.margin=grid::unit(c(0,0,0,0), "mm")) +
    labs(x = "Version",
         y = "KWD", color = "Estimator",
         title = ""))
ggsave("Poster/kwd.noise.plot.png", kwd.noise.plot, device = "png", bg = "transparent", width = 14)
```

```{r kwd-quant}
order.quant.levels <- c(str_subset(order.mismatch, "true"),
                        rev(str_subset(order.mismatch, "no_|true", negate = T))) %>% 
  str_replace(., "no_true", "true")  %>% 
  unique(.)

(kwd.quant.plot <- kwd.eval %>% 
    filter(iteration == n.iter.MLE) %>% 
    filter(version.kind %in% c("Quantization", "True")) %>% 
    mutate(version.ordered = factor(version, levels = order.quant.levels)) %>%
    ggplot(aes(x = version.ordered, y = kwd, color = estimator.kind, group = estimator.kind)) +
    geom_line(size = 1) +
    geom_point() +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version), 
                alpha = 0.2, color = "transparent") +
    geom_text_repel(aes(label = round(kwd, 2)), size = 3, show.legend  = F) +
    scale_color_ptol() +
    facet_wrap(vars(network.kind), scales = "free_x") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
          legend.position = "bottom") +
    labs(x = "Version",
         y = "KWD", color = "Estimator",
         title = "KWD final estimates Quantization model mismatch"))
```

### KWD convergence for numerical estimators

```{r kwd-convergence, warning=FALSE}
# log scale breaks for background grid
minor.breaks <- rep(1:9, 21) * (10^rep(-10:10, each = 9))

# develop line plot
(kwd.convergence.noise.plot <- kwd.eval %>% 
    filter(!estimator.kind == "flat") %>% 
    filter(version.kind == "Noise") %>% 
    mutate(version.ordered = factor(version, levels = order.noise.levels)) %>%
    group_by(version, estimator.kind, network.kind) %>%
    mutate(min.KWD = case_when(kwd == min(kwd) ~ T,
                               T ~ F)) %>%
    ungroup() %>%
    ggplot(aes(x = iteration, y = kwd, color = version.ordered)) +
    geom_line() +
    geom_point(aes(size = min.KWD), show.legend = F) +
    facet_wrap(vars(network.kind, estimator.kind), nrow = 2) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version.ordered), 
                alpha = 0.2, color = "transparent") +
    scale_color_ptol() +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x)),
                  minor_breaks = minor.breaks) +
    annotation_logticks(sides = "b") +
    labs(color = "Random Noise",
         x = "Iteration",
         y = "KWD",
         title = "Random Noise: KWD convergence behavior per estimator",
         subtitle = "The bigger dot indicates the lowest KWD value in the series") +
      theme(legend.position = "bottom"))

(kwd.convergence.quant.plot <- kwd.eval %>% 
    filter(!estimator.kind == "flat") %>% 
    filter(version.kind == "Quantization") %>% 
    mutate(version.ordered = factor(version, levels = order.quant.levels)) %>%
    group_by(version, estimator.kind, network.kind) %>%
    mutate(min.KWD = case_when(kwd == min(kwd) ~ T,
                               T ~ F)) %>%
    ungroup() %>%
    ggplot(aes(x = iteration, y = kwd, color = version.ordered)) +
    geom_line() +
    geom_point(aes(size = min.KWD), show.legend = F) +
    facet_wrap(vars(network.kind, estimator.kind), nrow = 2) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = version.ordered), 
                alpha = 0.2, color = "transparent") +
    scale_color_ptol() +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x)),
                  minor_breaks = minor.breaks) +
    annotation_logticks(sides = "b") +
    labs(color = "Quantization",
         x = "Iteration",
         y = "KWD",
         title = "Quantization: KWD convergence behavior per estimator",
         subtitle = "The bigger dot indicates the lowest KWD value in the series") +
      theme(legend.position = "bottom"))

```

```{r}
sessionInfo()
```
