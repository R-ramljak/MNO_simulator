---
title: "MNO spatial density estimates (rough draft!!!)"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: show
    code_download: true
    theme: sandstone
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: yes
---

# Introduction

Data generated by the cellular network of a mobile network operator (MNO) represent a rich potential source for estimating the spatial distribution of mobile phones at some given time and, from there, gain insight into the temporal variations of the spatial distribution of humans -- relevant for applications in, e.g., demography, tourism statistics and urban planning. The processing pipeline from raw MNO data to the final spatial density map requires modeling the (approximate) spatial footprint of individual radio cells -- a task called "cell geo-location".

Some recent work has shown that, with appropriate estimation methods based on stochastic models, the availability of more detailed cell footprint information allows to improve considerably the spatial accuracy of the final estimate compared with the simpler traditional methods relying on Voronoi tessellations. However, such results were obtained (i) under the assumption of perfect cell footprint knowledge and (ii) limited to a single scenario characterized by a dense multi-layer radio coverage pattern with high degree of cell overlapping.

In the present follow-up work we conduct an extensive sensitivity analysis of various estimators based on different cell geo-location methods. We investigate the sensitivity of estimation accuracy (i) to uncertainties in cell footprint modeling due to imperfect knowledge of the radio propagation environment and (ii) to various scenario parameters concerning the radio coverage pattern (e.g. density and degree of overlapping cells, multiple network layers). Owing to the spatial nature of the estimation problem, the Kantorovich-Wasserstein distance is used to measure the (dis)similarity between the estimated density and the true population distribution.

This notebook constitutes a working draft version of a future article concerning the spatial density estimation based on mobile network operator data (MNO). In the final version this notebook will accompany the article as a technical appendix. 


## Toyworld generation

The toyworld is created trough a semi-synthetic data. The general focus area is Munich and its near surroundings, the population values per tile are on the 100x100m level and originate from the German census. Finally, the radio network is fully synthetic and contains only directional cells. Cells are specified and modelled with the help of the `mobloc` package. The most important parameters are listed and visualized in the following:

```{r setup, message=FALSE}
# Data manipulation
library(tidyverse)
library(data.table) 

# Spatial operations
library(sf)
library(raster)
library(stars)

# Matrix operations
library(Matrix)

# MNO data handling and propagation model setup
# Credits to Prof. Martijn Tennekes https://github.com/mtennekes/mobloc
library(mobloc)

# Comparison of 2d histograms (Kantorovitch Wasserstein distance a.k.a. Earth Movers distance)
# Credits to Prof. Stefano Gualandi https://cran.r-project.org/web/packages/SpatialKWD/SpatialKWD.pdf
library(SpatialKWD)

# Output organisation and plotting support
library(ggthemes)
library(viridis)
library(ggrepel)
library(ggpointdensity)
library(scattermore)
library(grid)
library(gridExtra)
library(knitr)
library(DT)

# seed for reproducibility
set.seed(42)


# Loading Custom functions
source("pipeline functions.R")

```

### Specify the area and the mobile phone population

```{r population-data}
# data read in
munich.raw <- readRDS("Data/munich.rds")

# define raster object from focus area
munich.raster <- rasterFromXYZ(munich.raw, crs = st_crs(3035)$proj4string)

# define empty list object where all GTP objects will be stored
munich <- NULL

# define sf version of raster object
munich$area.sf <- munich.raster %>%
  st_as_stars() %>%
  st_as_sf() %>%
  mutate(centroid.geometry = st_centroid(.$geometry)) %>% 
  mutate(X.centroid = unlist(map(.$centroid.geometry, 1)),
         Y.centroid = unlist(map(.$centroid.geometry, 2))) %>% 
  dplyr::select(tile.id, pop, elevation, X.centroid, Y.centroid) %>%
  mutate(tile.id.chr = as.character(tile.id)) %>% 
  mutate(tile.id.fac = factor(tile.id.chr)) %>% 
  mutate(tile.id.num = as.numeric(tile.id.fac)) %>% 
  mutate(type = "NA") # only necessary if different tile types can be defined (urban, rural, etc...)

# regular dataframe version
munich$area.df <- munich$area.sf %>%
  st_drop_geometry()

# variable reduced dataframe version
munich$area.reduced.df <- munich$area.df %>% 
  dplyr::select(tile.id.chr, contains("centroid"))

# unionized version of focus area
munich$area.union <- munich$area.sf %>%
  st_union()

# bounding box coordinates of focus area
munich$area.bbox <- munich$area.union %>%
  st_bbox(crs = sf::st_crs(3035))

# specify raster object and tile id number
munich$area.raster <- munich.raster %>%
  raster(., layer = "tile.id")

# specify raster object and elevation value of each tile (here considered as constant)
munich$area.elevation <- munich.raster %>%
  raster(., layer = "elevation")

# number of tiles
munich$area.params[["tile.num"]] <- length(munich$area.df$tile.id)

# size of tiles
munich$area.params[["base.tile.size"]] <- as.numeric(sqrt(st_area(munich$area.sf[1,])))

# storing everything in area object
area <- munich

saveRDS(area, "workflow_objects/area.rds")
```

```{r gtp-map, fig.cap="Spatial population density of the ground truth population"}
# adjustable break points for map categories
breaks <- c(0, 2, 5, 10, 20, 50, 100, 200, 350, Inf)
# plot map and print
area$area.sf %>% 
  mutate(pop.cat = cut(pop, breaks = breaks, dig.lab = 7, right = F)) %>% 
  map_density(data = ., var = "pop.cat", label = "GTP")

```

```{r pop-summary}
# summary descriptives of GTP
pop_summary_results(area$area.sf) %>% 
  dplyr::select(n.tiles = n.type, mean.pop, sd.pop, min.pop, max.pop, sum.pop)

```

```{r density-plot, fig.cap="Distribution of the ground truth population"}
# ECCDF and ECDF of GTP
(density_plots(area$area.df))
```

### Generate a radio network

#### Specify the first batch of network parameters

```{r, network-parameters-1, message=FALSE, warning=FALSE, fig.height=8, fig.width=10, fig.cap="Theoretical radio network parameters for each layer"}
# specify parameters of each cell
ME.cell.param.mobloc <- mobloc_param(W = 50, range = 8000, ple = 3.7, height = 10,
                                     midpoint = -85, steepness = 0.3, sig_d_th = 0.05)
# create dataframe for theoretical signal strength distribution
param.df <- tibble(cell.kind = c("ME"),
                   label = c("Meso"),
                   W = c(ME.cell.param.mobloc$W),
                   ple = c(ME.cell.param.mobloc$ple),
                   range = c(ME.cell.param.mobloc$range),
                   midpoint = c(ME.cell.param.mobloc$midpoint),
                   steepness = c(ME.cell.param.mobloc$steepness),
                   dominance.th = c(ME.cell.param.mobloc$sig_d_th))

# reduced data frame of theoretical signal strength distribution
param.df.reduced <- param.df %>% 
  dplyr::select(cell.kind, dominance.th)

# theoretical signal strength parameter plots
sig.pram.plots <- sig_param_plots(param.df = param.df, range.max = 15000, base_size = 11)

# print
(a <- ggpubr::as_ggplot(sig.pram.plots$final))
```

#### Densification

As mentioned above the central hypothesis for the Voronoi estimators is that any mobile phone connects with the closest cell in terms of distance. This translates into a high correlation between signal dominance and distance (IS THIS CORRECT??). We expect this assumption to break the more cells that are potentially available for a specific tile - high cell competition translates into higher overlap. The higher the overlap, the worse the Voronoi estimators will perform.

To test this assumption, we specify three kinds of networks that differ in their level of coverage density. The higher the density the higher the overlap between different cell footprints. To actually measure this overlap, robust indicators still need to be explored. The different networks are categorized as (1) dense, (2) middle and (3) sparse. The density level is solely controlled by the `tower.dist` parameter within the custom `create_cells()` function. This parameter controls the distance between every border point within the hexagonal base grid for creating the network. Each border point will translate to a tower, which means that the smaller the distance the more towers will be created and the bigger the distance lesser towers will be created.

Later on we will improve this experiment by also introducing different network layers with different cell parameters. This will enrich the experiment as here the competing cells for a specific tile entail different network characteristics potentially decreasing even more the correlation between distance and signal dominance.

```{r}
set.seed(20)

# specify the level of density for the different networks
tower.dist.list <- c(dense = 2000, sparse = 4100)

ME.cells.unparam <- map(tower.dist.list, ~create_cells(area.sf = area$area.sf,
                                                       tower.dist = .x, rotation.deg = 35,
                                                       jitter = 3, small = FALSE,
                                                       subscript = "ME", seed = 7))


# create the cellplan and validate it with the specified parameters
ME.cellplan.val <- map(ME.cells.unparam, ~create_cellplan(area.sf = area$area.sf,
                                                          area.bbox = area$area.bbox,
                                                          area.elevation = area$area.elevation,
                                                          cells.unparam = .x,
                                                          cell.param.mobloc = ME.cell.param.mobloc))

# compute signal strength and device to cell association
ME.signal.strength <- map(ME.cellplan.val, ~compute_sig_strength(cp = .x$cellplan.val,
                                                                 raster = area$area.raster,
                                                                 param = .x$cell.param.mobloc,
                                                                 elevation = area$area.elevation))
```